xxxxxxxxx.xxx.x.xxx~xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxxxxxxxxxx~~~x~~~x~xxx                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

----------------------------------------------------------------

42sh/builtins/export/errors/001-invalid-identifier-1 (FAILED)

  Description:
  The purpose of this test is to check that trying to export an invalid variable identifier results in error.

  STDIN:
   1: export 42=TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `(not.*identifier|must begin.*letter)`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

42sh/builtins/export/errors/002-invalid-identifier-2 (FAILED)

  Description:
  The purpose of this test is to check that trying to export an invalid variable identifier results in error.

  STDIN:
   1: export .=TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `(not.*identifier|must begin.*letter)`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

42sh/builtins/export/errors/003-illegal-option (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `export` with an illegal option results in an error and a failure exit status.

  STDIN:
   1: export -w

  STDOUT:
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ii]nvalid|[Ii]llegal) (option|argument)`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

42sh/builtins/export/mixed/001-export-and-tmp-env-part1 (FAILED)

  Description:
   The purpose of this test is to check that modifying the environment for the builtin `export` results in an added variable into the exported list.

  Before test:
   1: unset "TOKEN201803301333_NAME"

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE export TOKEN201803301333_NAME
   2: export

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=["]?TOKEN201803301333_VALUE["]?`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/mixed/002-export-and-tmp-env-part2 (FAILED)

  Description:
   The purpose of this test is to check that modifying the environment for the builtin `export` results in an added environment variable.

  Before test:
   1: unset "TOKEN201803301333_NAME"

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE export TOKEN201803301333_NAME
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=TOKEN201803301333_VALUE`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/006-export-update-env-variable (FAILED)

  Description:
  The purpose of this test is to check that exporting the same variable twice in a row does result in an updated variable, but not in a duplicated variable.

  Before test:
   1: unset "TOKEN201803301333_NAME"

  STDIN:
   1: export TOKEN201803301333_NAME=TOKEN201803301333_VALUE1
   2: export TOKEN201803301333_NAME=TOKEN201803301333_VALUE2
   3: ./display_env

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_NAME=TOKEN201803301333_VALUE1`
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=TOKEN201803301333_VALUE2`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/008-local-to-environment (FAILED)

  Description:
  The purpose of this test is to check that a declared local variable may be exported to the environment with the builtin `export`.

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE
   2: export TOKEN201803301333_NAME
   3: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/010-export-with-equal-but-no-value-part2 (FAILED)

  Description:
  The purpose of this test is to check if the builtin export works fine with equal sign but no value. This test is based on the local variables return.

  Before test:
   1: unset "TOKEN201803301333"

  STDIN:
   1: export TOKEN201803301333_NAME=
   2: export

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/005-export-empty-variable-2 (FAILED)

  Description:
  The purpose of this test is to check that exporting an empty variable does not add it to the environment, but can be displayed with the builtin `export`.

  Before test:
   1: unset "TOKEN201803301333"

  STDIN:
   1: export TOKEN201803301333
   2: export

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/002-export-basic-key-value-1 (FAILED)

  Description:
  The purpose of this test is to check that the builtin `export` may declare a new environment variable.

  Before test:
   1: unset "TOKEN201803301333_NAME"

  STDIN:
   1: export TOKEN201803301333_NAME=TOKEN201803301333_VALUE
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/009-export-with-equal-but-no-value-part1 (FAILED)

  Description:
  The purpose of this test is to check if the builtin export works fine with equal sign but no value. This test is based on the environment variables return.

  Before test:
   1: unset "TOKEN201803301333"

  STDIN:
   1: export TOKEN201803301333_NAME=
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/options/002-export-p-param-and-token-should-add-local-var-only-part1 (FAILED)

  Description:
  The purpose of this test is to check if export with -p option + token , add the variable into export list but not in env list. And don't display the export variable on stdout.

  Before test:
   1: rm -f "./stored_env"
   2: unset "TOKEN201803301333_NAME"
   3: export | awk 'BEGIN {FS="="} $0 !~ /^(OLDPWD|_)/ {print $1"="}' > "./stored_env"

  STDIN:
   1: export -p TOKEN201803301333_NAME
   2: export

  STDOUT:
  SUCCESS    expected_to_not match_each_regex_of_file `./stored_env`
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/options/001-export-with-only-p-parameter (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `export` with the option `-p` results at least in a display of the environment variables.

  Before test:
   1: rm -rf "./stored_env"
   2: env | awk 'BEGIN {FS="="} $0 !~ /^(OLDPWD|_)/ {print $1"="}' > "./stored_env"

  STDIN:
   1: export -p

  STDOUT:
  FAILURE    expected_to match_each_regex_of_file `./stored_env`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/001-display-env (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `export` without parameters results at least in a display of the environment variables.

  Before test:
   1: rm -rf "./stored_env"
   2: env | awk 'BEGIN {FS="="} $0 !~ /^(OLDPWD|_)/ {print $1"="}' > "./stored_env"

  STDIN:
   1: export

  STDOUT:
  FAILURE    expected_to match_each_regex_of_file `./stored_env`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/003-export-basic-key-value-2 (FAILED)

  Description:
  The purpose of this test is to check that the builtin `export` may declare a new environment variable and is able to display it later.

  Before test:
   1: unset "TOKEN201803301333_NAME"

  STDIN:
   1: export TOKEN201803301333_NAME=TOKEN201803301333_VALUE
   2: export

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=["]?TOKEN201803301333_VALUE["]?$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/builtins/export/007-existing-environment-variable (FAILED)

  Description:
  The purpose of this test is to check that exporting an existing variable results in an updated variable.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE1"

  STDIN:
   1: export TOKEN201803301333_NAME=TOKEN201803301333_VALUE2
   2: ./display_env

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_NAME=TOKEN201803301333_VALUE1`
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=TOKEN201803301333_VALUE2`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/mixed/tilde-expansion/001-process-tilde-expansion (WARNING)

  Description:
  The purpose of this test is to check that the tilde expansion `~` in variable declaration.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: TOKEN201803301333=~
   2: ./write_on_stdout TILDE:$TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `TILDE:~`
  WARNING    might match_regex `TILDE:/TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/mixed/inline-environment-variable/001-local-variable-shouldnt-be-set (FAILED)

  Description:
  The purpose of this test is to check that declaring a variable and specifying a binary does not result in local variable declaration but a modified environment for the command.

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE ./display_env
   2: ./write_on_stderr $TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE$`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_VALUE`
  FAILURE    expected_to match_regex `write on stderr`
  (no output)

----------------------------------------------------------------

42sh/local-variable/mixed/redirections/002-appending (FAILED)

  Description:
  The purpose of this test is to check that a redirection can be set with a local variable as file name.

  Before test:
   1: rm -f "TOKEN201803301333_FILENAME"

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_FILENAME
   2: ./write_on_stdout TOKEN201803301333_VALUE1 >> $TOKEN201803301333_NAME
   3: ./write_on_stdout TOKEN201803301333_VALUE2 >> $TOKEN201803301333_NAME

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to create_file `TOKEN201803301333_FILENAME` matching_regex `^TOKEN201803301333_VALUE1$`
  FAILURE    expected_to create_file `TOKEN201803301333_FILENAME` matching_regex `^TOKEN201803301333_VALUE2$`
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

42sh/local-variable/mixed/redirections/003-reading (FAILED)

  Description:
  The purpose of this test is to check that a redirection can be set with a local variable as file name.

  Before test:
   1: rm -f "TOKEN201803301333_FILENAME"
   2: echo "TOKEN201803301333_VALUE" > "TOKEN201803301333_FILENAME"

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_FILENAME
   2: ./read_on_stdin < $TOKEN201803301333_NAME

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/mixed/redirections/001-truncating (FAILED)

  Description:
  The purpose of this test is to check that a redirection can be set with a local variable as file name.

  Before test:
   1: rm -f "TOKEN201803301333_FILENAME"

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_FILENAME
   2: ./write_on_stdout TOKEN201803301333_VALUE > $TOKEN201803301333_NAME

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to create_file `TOKEN201803301333_FILENAME` matching_regex `^TOKEN201803301333_VALUE$`
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

42sh/local-variable/003-unknown-variable-does-not-result-in-new-argument (FAILED)

  Description:
  The purpose of this test is to check that an unknown variable is not expanded as an empty string and results in any new argument in the command line.

  Before test:
   1: unset "TOKEN201803301333_UNKNOWN"

  STDIN:
   1: ./write_on_stdout $TOKEN201803301333_UNKNOWN TOKEN201803301333_DISPLAYED

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_DISPLAYED`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/007-multiple-declaration-at-a-time (FAILED)

  Description:
  The purpose of this test is to check that declaring multiple variables in the same command line does work.

  STDIN:
   1: TOKEN201803301333_NAME1=TOKEN201803301333_VALUE1 TOKEN201803301333_NAME2=TOKEN201803301333_VALUE2 TOKEN201803301333_NAME3=TOKEN201803301333_VALUE3
   2: ./write_on_stdout_and_stderr $TOKEN201803301333_NAME1 $TOKEN201803301333_NAME1
   3: ./write_on_stdout $TOKEN201803301333_NAME2
   4: ./write_on_stderr $TOKEN201803301333_NAME3

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE1$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE2$`
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333_VALUE3$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE1$`
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333_VALUE2$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE3$`
  (no output)

----------------------------------------------------------------

42sh/local-variable/006-existing-variable-in-environment-3 (FAILED)

  Description:
  The purpose of this test is to check that variable expansion takes the environment variables into account.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: ./write_on_stdout $TOKEN201803301333_NAME

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/001-declare-and-expand-1 (FAILED)

  Description:
  The purpose of this test is to check that declaring and expanding a local variable does work.

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE
   2: ./write_on_stdout_and_stderr $TOKEN201803301333_NAME $TOKEN201803301333_NAME

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE$`
  (no output)

----------------------------------------------------------------

42sh/local-variable/005-existing-variable-in-environment-2 (FAILED)

  Description:
  The purpose of this test is initialize a local variable named as an environment variable and check if it's update the existing environment variable.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: TOKEN201803301333_NAME=
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=$`
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/004-existing-variable-in-environment-1 (FAILED)

  Description:
  The purpose of this test is initialize a local variable named as an environment variable and check if it's update the existing environment variable.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE_OLD"

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE_NEW
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE_NEW$`
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE_OLD$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/009-last-exit-status (FAILED)

  Description:
  The purpose of this test is to check that the special variable `$?` may be expanded with the last exit status.

  STDIN:
   1: ./exit_with_status 42
   2: ./write_on_stderr $?

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^42$`
  (no output)

----------------------------------------------------------------

42sh/local-variable/008-multiple-declaration-with-same-name (FAILED)

  Description:
  The purpose of this test is to check that declaring the same variable several times in the same command line does work and does not result in error.

  STDIN:
   1: TOKEN201803301333_NAME=TOKEN201803301333_VALUE1 TOKEN201803301333_NAME=TOKEN201803301333_VALUE2 TOKEN201803301333_NAME=TOKEN201803301333_VALUE3
   2: ./write_on_stdout $TOKEN201803301333_NAME

  STDOUT:
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333_VALUE1$`
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333_VALUE2$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_VALUE3$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/local-variable/002-declare-and-expand-2 (FAILED)

  Description:
  The purpose of this test is to check that an empty variable is not expanded as an empty string and results in any new argument in the command line.

  STDIN:
   1: TOKEN201803301333_NAME=
   2: ./write_on_stdout_and_stderr $TOKEN201803301333_NAME $TOKEN201803301333_NAME

  STDOUT:
  FAILURE    expected_to match_regex `write on stdout`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `write on stderr`
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/013-multiple-1 (FAILED)

  Description:
  The purpose of this test is to check that brace expansion may be performed with multiple brace patterns.

  STDIN:
   1: ./write_all_arguments_on_stdout {1..2}{3..4}{5..6}

  STDOUT:
  FAILURE    expected_to match_regex `^135@136@145@146@235@236@245@246@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/006-simple-descending-1 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {5..1}

  STDOUT:
  FAILURE    expected_to match_regex `^5@4@3@2@1@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/008-simple-descending-3 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{5..+1}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN2018033013335@TOKEN2018033013334@TOKEN2018033013333@TOKEN2018033013332@TOKEN2018033013331@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/004-simple-ascending-4 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {-5..0}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^-5TOKEN201803301333@-4TOKEN201803301333@-3TOKEN201803301333@-2TOKEN201803301333@-1TOKEN201803301333@0TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/015-big-range (FAILED)

  Description:
  The purpose of this test is to check that brace expansion may be performed with a big numeric range.

  STDIN:
   1: ./write_all_arguments_on_stdout {-100..100}

  STDOUT:
  FAILURE    expected_to match_regex `^-100@-99@-98@-97@-96@-95@-94@-93@-92@-91@-90@-89@-88@-87@-86@-85@-84@-83@-82@-81@-80@-79@-78@-77@-76@-75@-74@-73@-72@-71@-70@-69@-68@-67@-66@-65@-64@-63@-62@-61@-60@-59@-58@-57@-56@-55@-54@-53@-52@-51@-50@-49@-48@-47@-46@-45@-44@-43@-42@-41@-40@-39@-38@-37@-36@-35@-34@-33@-32@-31@-30@-29@-28@-27@-26@-25@-24@-23@-22@-21@-20@-19@-18@-17@-16@-15@-14@-13@-12@-11@-10@-9@-8@-7@-6@-5@-4@-3@-2@-1@0@1@2@3@4@5@6@7@8@9@10@11@12@13@14@15@16@17@18@19@20@21@22@23@24@25@26@27@28@29@30@31@32@33@34@35@36@37@38@39@40@41@42@43@44@45@46@47@48@49@50@51@52@53@54@55@56@57@58@59@60@61@62@63@64@65@66@67@68@69@70@71@72@73@74@75@76@77@78@79@80@81@82@83@84@85@86@87@88@89@90@91@92@93@94@95@96@97@98@99@100@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/009-simple-descending-4 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {0..-5}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^0TOKEN201803301333@-1TOKEN201803301333@-2TOKEN201803301333@-3TOKEN201803301333@-4TOKEN201803301333@-5TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/007-simple-descending-2 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{5..1}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN2018033013335TOKEN201803301333@TOKEN2018033013334TOKEN201803301333@TOKEN2018033013333TOKEN201803301333@TOKEN2018033013332TOKEN201803301333@TOKEN2018033013331TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/003-simple-ascending-3 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{1..+5}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN2018033013331@TOKEN2018033013332@TOKEN2018033013333@TOKEN2018033013334@TOKEN2018033013335@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/011-identical-positive-start-and-end (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a range of single value.

  STDIN:
   1: ./write_all_arguments_on_stdout {42..42}

  STDOUT:
  FAILURE    expected_to match_regex `^42@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/014-multiple-2 (FAILED)

  Description:
  The purpose of this test is to check that brace expansion may be performed with multiple brace patterns.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{1..2}abc{-50..-53}def{0..0}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN2018033013331abc-50def0@TOKEN2018033013331abc-51def0@TOKEN2018033013331abc-52def0@TOKEN2018033013331abc-53def0@TOKEN2018033013332abc-50def0@TOKEN2018033013332abc-51def0@TOKEN2018033013332abc-52def0@TOKEN2018033013332abc-53def0@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/010-simple-descending-5 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {-98..-100}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^-98TOKEN201803301333@-99TOKEN201803301333@-100TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/002-simple-ascending-2 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{1..5}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN2018033013331TOKEN201803301333@TOKEN2018033013332TOKEN201803301333@TOKEN2018033013333TOKEN201803301333@TOKEN2018033013334TOKEN201803301333@TOKEN2018033013335TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/001-simple-ascending-1 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {1..5}

  STDOUT:
  FAILURE    expected_to match_regex `^1@2@3@4@5@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/005-simple-ascending-5 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a numeric range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {-100..-98}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^-100TOKEN201803301333@-99TOKEN201803301333@-98TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/numeric-range/012-identical-negative-start-and-end (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a range of single value.

  STDIN:
   1: ./write_all_arguments_on_stdout {-42..-42}

  STDOUT:
  FAILURE    expected_to match_regex `^-42@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/errors/004-invalid-pattern-4 (FAILED)

  Description:
  The purpose of this test is to check that invalid braces expansion patterns does not result in error.

  STDIN:
   1: ./write_on_stdout {Q..C..1}

  STDOUT:
  FAILURE    expected_to match_regex `^{Q..C..1}$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

42sh/globbing/brace-expansion/errors/003-invalid-pattern-3 (FAILED)

  Description:
  The purpose of this test is to check that invalid braces expansion patterns does not result in error.

  STDIN:
   1: ./write_on_stdout {..C}

  STDOUT:
  FAILURE    expected_to match_regex `^{..C}$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

42sh/globbing/brace-expansion/errors/001-invalid-pattern-1 (FAILED)

  Description:
  The purpose of this test is to check that invalid braces expansion patterns does not result in error.

  STDIN:
   1: ./write_on_stdout {A}

  STDOUT:
  FAILURE    expected_to match_regex `^{A}$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

42sh/globbing/brace-expansion/errors/002-invalid-pattern-2 (FAILED)

  Description:
  The purpose of this test is to check that invalid braces expansion patterns does not result in error.

  STDIN:
   1: ./write_on_stdout {B..}

  STDOUT:
  FAILURE    expected_to match_regex `^{B..}$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

42sh/globbing/brace-expansion/list-of-values/001-nothing-to-be-done (FAILED)

  Description:
  The purpose of this test is to check that brace expansion is not processed when neither range `..` nor comma `,` tokens is specified.

  STDIN:
   1: ./write_on_stdout {TOKEN201803301333}

  STDOUT:
  FAILURE    expected_to match_regex `{TOKEN201803301333}`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/list-of-values/003-simple-test-2 (FAILED)

  Description:
  The purpose of this test is to check that brace expansion is processed with a list of three patterns.

  STDIN:
   1: ./write_all_arguments_on_stdout {TOKEN201803301333_A,TOKEN201803301333_B,TOKEN201803301333_C}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_A@TOKEN201803301333_B@TOKEN201803301333_C@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/list-of-values/002-simple-test-1 (FAILED)

  Description:
  The purpose of this test is to check that brace expansion is processed when at least one comma `,` is encountered.

  STDIN:
   1: ./write_all_arguments_on_stdout {TOKEN201803301333_A,TOKEN201803301333_B}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_A@TOKEN201803301333_B@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/007-identical-start-and-end (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with a range of single ASCII value.

  STDIN:
   1: ./write_all_arguments_on_stdout {f..f}

  STDOUT:
  FAILURE    expected_to match_regex `^f@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/010-big-range (FAILED)

  Description:
  The purpose of this test is to check that brace expansion may be performed with a big numeric range.

  STDIN:
   1: ./write_all_arguments_on_stdout {A..z}

  STDOUT:
  FAILURE    expected_to match_regex `^A@B@C@D@E@F@G@H@I@J@K@L@M@N@O@P@Q@R@S@T@U@V@W@X@Y@Z@.+@.?@.+@.+@_@.+@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/008-multiple-1 (FAILED)

  Description:
  The purpose of this test is to check that brace expansion may be performed with multiple brace patterns.

  STDIN:
   1: ./write_all_arguments_on_stdout {a..b}{c..d}{e..f}

  STDOUT:
  FAILURE    expected_to match_regex `^ace@acf@ade@adf@bce@bcf@bde@bdf@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/006-simple-descending-3 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with an ASCII range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{e..a}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333e@TOKEN201803301333d@TOKEN201803301333c@TOKEN201803301333b@TOKEN201803301333a@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/003-simple-ascending-3 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with an ASCII range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {A..E}

  STDOUT:
  FAILURE    expected_to match_regex `^A@B@C@D@E@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/009-multiple-2 (FAILED)

  Description:
  The purpose of this test is to check that brace expansion may be performed with multiple brace patterns.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{a..b}abc{Z..X}def{s..s}

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333aabcZdefs@TOKEN201803301333aabcYdefs@TOKEN201803301333aabcXdefs@TOKEN201803301333babcZdefs@TOKEN201803301333babcYdefs@TOKEN201803301333babcXdefs@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/005-simple-descending-2 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with an ASCII range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{E..A}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333ETOKEN201803301333@TOKEN201803301333DTOKEN201803301333@TOKEN201803301333CTOKEN201803301333@TOKEN201803301333BTOKEN201803301333@TOKEN201803301333ATOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/002-simple-ascending-2 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with an ASCII range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout TOKEN201803301333{a..e}TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333aTOKEN201803301333@TOKEN201803301333bTOKEN201803301333@TOKEN201803301333cTOKEN201803301333@TOKEN201803301333dTOKEN201803301333@TOKEN201803301333eTOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/001-simple-ascending-1 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with an ASCII range in ascending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {a..e}

  STDOUT:
  FAILURE    expected_to match_regex `^a@b@c@d@e@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/brace-expansion/ascii-range/004-simple-descending-1 (FAILED)

  Description:
  The purpose of this test is to check that the brace expansion does work with an ASCII range in descending order.

  STDIN:
   1: ./write_all_arguments_on_stdout {E..A}

  STDOUT:
  FAILURE    expected_to match_regex `^E@D@C@B@A@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/simple-pattern/001-simple-list (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with a simple list of characters as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'd' 'e' 'f' '[bca]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [bca]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `b@`
  FAILURE    expected_to match_regex `c@`
  SUCCESS    expected_to_not match_regex `d@`
  SUCCESS    expected_to_not match_regex `e@`
  SUCCESS    expected_to_not match_regex `f@`
  SUCCESS    expected_to_not match_regex `[[]bca]@`
  WARNING    might match_regex `^a@b@c@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/simple-pattern/004-multi-bracket-multi-char (FAILED)

  Description:
  The purpose of this test is to match a file name which contain a bracket as first character.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 21 23 24 25 26 27 28 29 ']' '[' '[12][34]' '1234'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [12][34]

  STDOUT:
  FAILURE    expected_to match_regex `13@`
  FAILURE    expected_to match_regex `14@`
  FAILURE    expected_to match_regex `23@`
  FAILURE    expected_to match_regex `24@`
  SUCCESS    expected_to_not match_regex `0[0-9]@`
  SUCCESS    expected_to_not match_regex `1[0-2]@`
  SUCCESS    expected_to_not match_regex `1[5-9]@`
  SUCCESS    expected_to_not match_regex `2[0-2]@`
  SUCCESS    expected_to_not match_regex `2[5-9]@`
  SUCCESS    expected_to_not match_regex `[[]@`
  SUCCESS    expected_to_not match_regex `]@`
  SUCCESS    expected_to_not match_regex `[[]12][[]34]@`
  SUCCESS    expected_to_not match_regex `1234@`
  WARNING    might match_regex `^13@14@23@24@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/simple-pattern/003-brackets-as-pattern (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with an opening bracket `[` and a closing bracket `]` as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '[' ']' 'a' 'Z' '[][]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [][]

  STDOUT:
  FAILURE    expected_to match_regex `[[]@`
  FAILURE    expected_to match_regex `]@`
  SUCCESS    expected_to_not match_regex `a@`
  SUCCESS    expected_to_not match_regex `Z@`
  SUCCESS    expected_to_not match_regex `[[]][[]]@`
  WARNING    might match_regex `^[[]@]@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/simple-pattern/002-multi-bracket (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with multiple brackets patterns.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch "TOKEN201803301333abcd" "TOKEN201803301333abc" "TOKEN201803301333abdc" "TOKEN201803301333b" "TOKEN201803301333" "TOKEN201803301333\[a]b\[c]\[d]"

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout TOKEN201803301333[a]b[c][d]

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333abcd@$`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333abc@`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333abdc@`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333b@`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333@`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333[[]a]b[[]c][[]d]@`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/multi/002-reverse-range-and-chars (FAILED)

  Description:
  The purpose of this test is to check that brackets expansion works with 2 patterns.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a4' 'a3' 'a2' 'a42' 'a[42]' 'z4' 'z3' 'z2' 'z42' 'z[42]' '42'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [!a-y][42]
   2: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [^a-y][42]

  STDOUT:
  FAILURE    expected_to match_regex `42@`
  FAILURE    expected_to match_regex `z4@`
  FAILURE    expected_to match_regex `z2@`
  SUCCESS    expected_to_not match_regex `z3@`
  SUCCESS    expected_to_not match_regex `z42@`
  SUCCESS    expected_to_not match_regex `z[[]42]@`
  SUCCESS    expected_to_not match_regex `a3@`
  SUCCESS    expected_to_not match_regex `a42@`
  SUCCESS    expected_to_not match_regex `a[[]42]@`
  WARNING    might match_regex `^42@z2@z4@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/multi/004-simple-bracket+char+range (FAILED)

  Description:
  The purpose of this test is to control if 2 patterns splited by a minus characters can be match.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a-0' 'a-1' 'a-2' 'b-0' 'b-1' 'b-2' 'Z-0' 'Z-1' 'Z-2' 'a1' 'Z9' 'D4'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [aZ]-[1-9]

  STDOUT:
  FAILURE    expected_to match_regex `a-1@`
  FAILURE    expected_to match_regex `a-2@`
  FAILURE    expected_to match_regex `Z-1@`
  FAILURE    expected_to match_regex `Z-2@`
  SUCCESS    expected_to_not match_regex `a-0@`
  SUCCESS    expected_to_not match_regex `b-0@`
  SUCCESS    expected_to_not match_regex `b-1@`
  SUCCESS    expected_to_not match_regex `b-2@`
  SUCCESS    expected_to_not match_regex `a1@`
  SUCCESS    expected_to_not match_regex `Z9@`
  SUCCESS    expected_to_not match_regex `D4@`
  WARNING    might match_regex `^Z-1@Z-2@a-1@a-2@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/multi/001-range-and-char (FAILED)

  Description:
  The purpose of this test is to check that brackets expansion works with a range and 2 characters as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '1' '2' '3' 'a' 'b' 'z' 'C' '-' '[a-z-2]' 'a-z-2'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [a-z-2]

  STDOUT:
  FAILURE    expected_to match_regex `-@`
  FAILURE    expected_to match_regex `2@`
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `b@`
  FAILURE    expected_to match_regex `z@`
  SUCCESS    expected_to_not match_regex `1@`
  SUCCESS    expected_to_not match_regex `3@`
  SUCCESS    expected_to_not match_regex `C@`
  SUCCESS    expected_to_not match_regex `[[]a-z-2]@`
  SUCCESS    expected_to_not match_regex `a-z-2@`
  WARNING    might match_regex `^-@2@a@b@z@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/multi/003-reverse-multi-hard (FAILED)

  Description:
  The purpose of this test is to check how the value inside multiple brackets are parsed with bracket as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '][' 'a[' '1['

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [!]az][[]
   2: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [^]az][[]

  STDOUT:
  FAILURE    expected_to match_regex `1[[]@`
  SUCCESS    expected_to_not match_regex `][[]@`
  SUCCESS    expected_to_not match_regex `a[[]@`
  WARNING    might match_regex `^1[[]@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/not/002-simple-opposite-range (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with the inversion mark `!` or `^`. The expected behavior is the reversion of the following pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'z' '1' '2' '3' '42'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [!a-z]
   2: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [^a-z]

  STDOUT:
  FAILURE    expected_to match_regex `1@`
  FAILURE    expected_to match_regex `2@`
  FAILURE    expected_to match_regex `3@`
  SUCCESS    expected_to_not match_regex `42@`
  WARNING    might match_regex `^1@2@3@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/not/001-simple-opposit-match (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with the inversion mark `!` or `^`. The expected behavior is the reversion of the following pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' '1' 'Z' 'd' 'e' 'f' 'def'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [!a1Z]
   2: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [^a1Z]

  STDOUT:
  FAILURE    expected_to match_regex `d@`
  FAILURE    expected_to match_regex `e@`
  FAILURE    expected_to match_regex `f@`
  SUCCESS    expected_to_not match_regex `def@`
  WARNING    might match_regex `^d@e@f@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/range-pattern/003-ascii-range-1 (FAILED)

  Description:
  The purpose of this test is to check if the bracket expansion works with the following pattern []-z].
  One test use the following range which is the default range for bash:
  < > , ; : ! ' " ( ) [ ] { } @ $ \ # % 1 2 3 4 5 6 7 8 9 a A b B c C d D e E f F g G h H i I j J k K l L m M n N o O p P q Q r R s S t T u U v V w W x X y Y z
  The other use the ascii value, which does make more sense.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '2' 'a' 'B' 'c' 'Z' '[' ']' '[]-z]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout []-z]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `c@`
  FAILURE    expected_to match_regex `]@`
  SUCCESS    expected_to_not match_regex `2@`
  SUCCESS    expected_to_not match_regex `B@`
  SUCCESS    expected_to_not match_regex `Z@`
  SUCCESS    expected_to_not match_regex `[[]@`
  SUCCESS    expected_to_not match_regex `[[]]-z]@`
  WARNING    might match_regex `^]@a@c@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/range-pattern/002-numeric-range (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with the following pattern `[0-9]`.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '4' '2' '1' '9' 'a' 'C' '[0-9]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [0-9]

  STDOUT:
  FAILURE    expected_to match_regex `1@`
  FAILURE    expected_to match_regex `2@`
  FAILURE    expected_to match_regex `4@`
  FAILURE    expected_to match_regex `9@`
  SUCCESS    expected_to_not match_regex `a@`
  SUCCESS    expected_to_not match_regex `C@`
  SUCCESS    expected_to_not match_regex `[[]0-9]@`
  WARNING    might match_regex `^1@2@4@9@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/range-pattern/004-ascii-range-2 (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with the following pattern `[1-z]`.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '2' 'a' 'B' 'c' 'Z' ']' '[' '[1-z]' '1-z' '-'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [1-z]

  STDOUT:
  FAILURE    expected_to match_regex `2@`
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `B@`
  FAILURE    expected_to match_regex `c@`
  FAILURE    expected_to match_regex `Z@`
  FAILURE    expected_to match_regex `]@`
  FAILURE    expected_to match_regex `[[]@`
  SUCCESS    expected_to_not match_regex `-@`
  SUCCESS    expected_to_not match_regex `1-z@`
  SUCCESS    expected_to_not match_regex `[[]1-z]@`
  WARNING    might match_regex `^2@B@Z@[[]@]@a@c@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/range-pattern/001-alpha-range (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with the following pattern `[a-z]`.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'f' 'z' 'A' '1' '[a-z]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [a-z]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `f@`
  FAILURE    expected_to match_regex `z@`
  SUCCESS    expected_to_not match_regex `A@`
  SUCCESS    expected_to_not match_regex `1@`
  SUCCESS    expected_to_not match_regex `[[]a-z]@`
  WARNING    might match_regex `^a@f@z@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/single-char-pattern/002-closing-bracket-char (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with a closing bracket `]` as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch ']' '[]]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout []]

  STDOUT:
  FAILURE    expected_to match_regex `]@`
  SUCCESS    expected_to_not match_regex `[[]]]@`
  WARNING    might match_regex `^]@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/single-char-pattern/003-opening-bracket-char (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with an opening bracket `[` as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch '[' '[[]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [[]

  STDOUT:
  FAILURE    expected_to match_regex `[[]@`
  SUCCESS    expected_to_not match_regex `[[][[]]@`
  WARNING    might match_regex `^[[]@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/globbing/bracket-expansion/single-char-pattern/001-single-char (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with a single character as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' '[a]'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [a]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  SUCCESS    expected_to_not match_regex `b@`
  SUCCESS    expected_to_not match_regex `[[]a]@`
  WARNING    might match_regex `^a@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/errors/003-parse-error-3 (FAILED)

  Description:
  The purpose of this test is to check that the parser detects an invalid use of parentheses.

  STDIN:
   1: ./write_on_stdout ) (./write_on_stdout)

  STDOUT:
  SUCCESS    expected_to_not match_regex `write_on_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

----------------------------------------------------------------

42sh/subshell/errors/001-parse-error-1 (FAILED)

  Description:
  The purpose of this test is to check that the parser detects an invalid use of parentheses.

  STDIN:
   1: ./write_on_stdout (./write_on_stdout)

  STDOUT:
  SUCCESS    expected_to_not match_regex `write_on_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

----------------------------------------------------------------

42sh/subshell/errors/002-parse-error-2 (FAILED)

  Description:
  The purpose of this test is to check that the parser detects an invalid use of parentheses.

  STDIN:
   1: (./write_on_stdout) (./write_on_stdout)

  STDOUT:
  SUCCESS    expected_to_not match_regex `write_on_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

----------------------------------------------------------------

42sh/subshell/errors/004-parse-error-4 (FAILED)

  Description:
  The purpose of this test is to check that the parser detects an invalid use of parentheses.

  STDIN:
   1: ./write_on_stdout ( (./write_on_stdout)

  STDOUT:
  SUCCESS    expected_to_not match_regex `write_on_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/builtins/cd/001-it-does-not-change-current-directory (FAILED)

  Description:
  The purpose of this test is to check that the part of a command line that is embraced within the subshell tokens `(` and `)` effectively results in a subshell execution.

  STDIN:
   1: (cd /)
   2: ./display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `/home/pi/42ShellTester/tmp`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/builtins/cd/002-multiline (FAILED)

  Description:
  The purpose of this test is to check that the Shell implementation may parse a subshell command on multiple lines.

  STDIN:
   1: (
   2: cd / ;
   3: /home/pi/42ShellTester/tmp/write_on_stdout TOKEN201803301333_SUBSHELL ;
   4: /home/pi/42ShellTester/tmp/display_pwd
   5: )
   6: ./write_on_stdout TOKEN201803301333_PARENT

  STDOUT:
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmp`
  FAILURE    expected_to match_regex `^PWD:/:PWD$`
  FAILURE    expected_to match_regex `TOKEN201803301333_SUBSHELL`
  FAILURE    expected_to match_regex `TOKEN201803301333_PARENT`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/builtins/exit/001-exiting-subshell (FAILED)

  Description:
  The purpose of this test is to check that prematurely exiting a subshell does work and does not result in parent shell termination.

  STDIN:
   1: (exit ; ./write_on_stdout TOKEN201803301333_NOT_DISPLAYED)
   2: ./write_on_stdout TOKEN201803301333_DISPLAYED

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_NOT_DISPLAYED`
  FAILURE    expected_to match_regex `TOKEN201803301333_DISPLAYED`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/builtins/unsetenv/001-it-does-not-modify-parent-environment (FAILED)

  Description:
  The purpose of this test is to check that changing environment in subshell commands does not result in a changed of the parent shell's environment.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: (unsetenv TOKEN201803301333_NAME ; unset TOKEN201803301333_NAME)
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME=TOKEN201803301333_VALUE`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/quoting/002-with-double-quotes (FAILED)

  Description:
  The purpose of this test is to check that the command line parser correctly takes in account the inhibitor symbol `"`.

  STDIN:
   1: (./write_on_stdout "TOKEN201803301333_FIRST)" ; (./write_on_stdout "(TOKEN201803301333_SECOND") )

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST`
  FAILURE    expected_to match_regex `TOKEN201803301333_SECOND`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/quoting/001-with-simple-quotes (FAILED)

  Description:
  The purpose of this test is to check that the command line parser correctly takes in account the inhibitor symbol `'`.

  STDIN:
   1: (./write_on_stdout 'TOKEN201803301333_FIRST)' ; (./write_on_stdout '(TOKEN201803301333_SECOND') )

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST`
  FAILURE    expected_to match_regex `TOKEN201803301333_SECOND`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/quoting/003-with-simple-and-double-quotes (FAILED)

  Description:
  The purpose of this test is to check that the command line parser correctly takes in account the inhibitor symbols `'` and `"`.

  STDIN:
   1: (./write_on_stdout "TOKEN201803301333_FIRST)" ; (./write_on_stdout '(TOKEN201803301333_SECOND') )

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST`
  FAILURE    expected_to match_regex `TOKEN201803301333_SECOND`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/piping/003-imbricated-subshells-and-pipes (FAILED)

  Description:
  The purpose of this test is to check that pipes and subshells run twice together in harmony.

  STDIN:
   1: ( ( (cd / ; /home/pi/42ShellTester/tmp/display_pwd) | ./read_on_stdin) ) | ( ( (./read_on_stdin) ) | ./read_on_stdin )
   2: ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmp`
  FAILURE    expected_to match_regex `^PWD:/:PWD@@@$`
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/piping/001-subshells-inside-piped-command (FAILED)

  Description:
  The purpose of this test is to check that subshells may be executed inside a piped command.

  STDIN:
   1: (cd / ; /home/pi/42ShellTester/tmp/display_pwd) | (./read_on_stdin) | (./read_on_stdin)
   2: ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmp`
  FAILURE    expected_to match_regex `^PWD:/:PWD@@$`
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/piping/002-pipes-inside-subshells (FAILED)

  Description:
  The purpose of this test is to check that piped command may be executed inside a subshell command.

  STDIN:
   1: (cd / ; /home/pi/42ShellTester/tmp/display_pwd | /home/pi/42ShellTester/tmp/read_on_stdin | /home/pi/42ShellTester/tmp/read_on_stdin)
   2: ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmp`
  FAILURE    expected_to match_regex `^PWD:/:PWD@@$`
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/inline-environment-variable/001-modifies-the-child-environment-only-1 (FAILED)

  Description:
  The purpose of this test is to check that declaring a variable and specifying a binary in a subshell does not result in local variable declaration or a modified parent shell's environment, but only a modified child's environment.

  STDIN:
   1: (TOKEN201803301333_NAME=TOKEN201803301333_VALUE ./display_env)
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE$` once
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/inline-environment-variable/002-modifies-the-child-environment-only-2 (FAILED)

  Description:
  The purpose of this test is to check that declaring a variable and specifying a binary in a subshell does not result in local variable declaration or a modified parent shell's environment, but only a modified child's environment.

  STDIN:
   1: ( (TOKEN201803301333_NAME=TOKEN201803301333_VALUE ./display_env) ; ./display_env) ; ./display_env
   2: 

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_NAME=TOKEN201803301333_VALUE$` once
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/escaping/001-escaped-subshell-1 (FAILED)

  Description:
  The purpose of this test is to check that a subshell with parentheses `(` and `)` may be escaped with backslash `\\`.

  STDIN:
   1: \(./write_on_stdout TOKEN201803301333_STDOUT\)

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_STDOUT`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Cc]ommand not found|[Nn]o such file or directory)`
  (no output)

----------------------------------------------------------------

42sh/subshell/mixed/escaping/002-escaped-subshell-2 (FAILED)

  Description:
  The purpose of this test is to check that the tokens parentheses `(` and `)` for subshell generation may be escaped with backslash `\\`.

  STDIN:
   1: ./write_on_stdout \\\(TOKEN201803301333_STDOUT\\\)

  STDOUT:
  FAILURE    expected_to match_regex `\(TOKEN201803301333_STDOUT\)`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/002-multiple-levels-of-subshells (FAILED)

  Description:
  The purpose of this test is to check that imbricating multiple subshells does not result in error.

  STDIN:
   1: ( ( ( ( ./write_on_stdout TOKEN201803301333 ) ) ) )

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/004-exit-status (FAILED)

  Description:
  The purpose of this test is to check that the exit status of a subshell command that is executed at the end of a script is correctly returned at termination by the parent shell.

  STDIN:
   1: (./exit_with_status 42)

  STDOUT:
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status 42

----------------------------------------------------------------

42sh/subshell/005-copy-of-environment (FAILED)

  Description:
  The purpose of this test is to check that a subshell get a copy of the parent environment.

  Before test:
   1: export "TOKEN201803301333_VAR1=VALUE1"
   2: export "TOKEN201803301333_VAR2=VALUE2"
   3: export "TOKEN201803301333_VAR3=VALUE3"

  STDIN:
   1: (./display_env)

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_VAR1=VALUE1`
  FAILURE    expected_to match_regex `TOKEN201803301333_VAR2=VALUE2`
  FAILURE    expected_to match_regex `TOKEN201803301333_VAR3=VALUE3`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/subshell/003-multiline (FAILED)

  Description:
  The purpose of this test is to check that the Shell implementation may parse a subshell command on multiple lines.

  STDIN:
   1: (
   2: ./write_on_stdout TOKEN201803301333_SUBSHELL1 ;
   3: ./write_on_stdout TOKEN201803301333_SUBSHELL2
   4: )

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_SUBSHELL1`
  FAILURE    expected_to match_regex `TOKEN201803301333_SUBSHELL2`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/subshell/001-tokens-are-recognized (FAILED)

  Description:
  The purpose of this test is to check that adding twice symbols `(` and `)` in a command line does not make the Shell resulting in error.

  STDIN:
   1: (./write_on_stdout TOKEN201803301333)

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/mixed/variable-expansion/001-it-does-not-expand-in-quotes (FAILED)

  Description:
   The purpose of this test is to check if a local variable is display correctly inside simple and double quote.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: ./write_on_stdout "$TOKEN201803301333_NAME"$TOKEN201803301333_NAME'$TOKEN201803301333_NAME'

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_VALUETOKEN201803301333_VALUE[$]TOKEN201803301333_NAME`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/mixed/globbing/brace-expansion/001-it-does-not-expand-braces-1 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout "{1..2}"{1..2}'{1..2}'{1..2}"{1..2}"{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}1[{]1..2}1[{]1..2}1@[{]1..2}1[{]1..2}1[{]1..2}2@[{]1..2}1[{]1..2}2[{]1..2}1@[{]1..2}1[{]1..2}2[{]1..2}2@[{]1..2}2[{]1..2}1[{]1..2}1@[{]1..2}2[{]1..2}1[{]1..2}2@[{]1..2}2[{]1..2}2[{]1..2}1@[{]1..2}2[{]1..2}2[{]1..2}2@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/mixed/globbing/bracket-expansion/002-it-works-2 (FAILED)

  Description:
  The purpose of this test is to check that an argument made with quoted and unquoted parts results in bracket pattern expansion.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout ["a"bc'def'gh]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `b@`
  FAILURE    expected_to match_regex `c@`
  FAILURE    expected_to match_regex `d@`
  FAILURE    expected_to match_regex `e@`
  FAILURE    expected_to match_regex `f@`
  FAILURE    expected_to match_regex `g@`
  FAILURE    expected_to match_regex `h@`
  SUCCESS    expected_to_not match_regex `bc`
  SUCCESS    expected_to_not match_regex `def`
  SUCCESS    expected_to_not match_regex `gh`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/mixed/globbing/bracket-expansion/001-it-works-1 (FAILED)

  Description:
  The purpose of this test is to check that an argument made with quoted and unquoted parts results in bracket pattern expansion.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [""'a'""]

  STDOUT:
  SUCCESS    expected_to_not match_regex `[[]a]@`
  FAILURE    expected_to match_regex `^a@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/mixed/002-multiline (FAILED)

  Description:
  The purpose of this test is to check that the symbols simple quote `'` and double quote `"` may work together in harmony in multiline mode.

  STDIN:
   1: ./write_on_stdout_and_stderr '
   2: 'TOKEN201803301333"_FIR'ST
   3: TOKEN201803301333_SECOND" 'TOKEN201803301333_TH"IRD
   4: TOKEN201803301333_FOU'RT"H
   5: "

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_FIR'ST$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_SECOND$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^TOKEN201803301333_TH"IRD$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_FOURTH$`
  (no output)

----------------------------------------------------------------

42sh/quoting/mixed/001-simple-and-double-quotes (FAILED)

  Description:
  The purpose of this test is to check that the symbols simple quote `'` and double quote `"` may work together in harmony.

  STDIN:
   1: ./write_on_stdout_and_stderr "ABCD'EFG"HI'J"KL"'MNO'P"' Q"RS'T'U''"VW'X"Y'Z

  STDOUT:
  FAILURE    expected_to match_regex `ABCD'EFGHIJ"KL"MNOP`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `QRS'T'U''VWX"YZ`
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/variable-expansion/001-expansion-enabled (FAILED)

  Description:
  The purpose of this test is to check that variable expansion is processed within double quotes.

  Before test:
   1: export "TOKEN=TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout "$TOKEN"

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/brace-expansion/002-it-does-not-expand-braces-2 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout {1..2}"{1..2}"

  STDOUT:
  FAILURE    expected_to match_regex `1[{]1..2}@2[{]1..2}@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/brace-expansion/005-it-does-not-expand-braces-5 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout "{1..2}" {1..2} "{1..2}" "{1..2}"

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}@1@2@[{]1..2}@[{]1..2}@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/brace-expansion/004-it-does-not-expand-braces-4 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout "{1..2}"{1..2}"{1..2}"{1..2}"{1..2}"{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}1[{]1..2}1[{]1..2}1@[{]1..2}1[{]1..2}1[{]1..2}2@[{]1..2}1[{]1..2}2[{]1..2}1@[{]1..2}1[{]1..2}2[{]1..2}2@[{]1..2}2[{]1..2}1[{]1..2}1@[{]1..2}2[{]1..2}1[{]1..2}2@[{]1..2}2[{]1..2}2[{]1..2}1@[{]1..2}2[{]1..2}2[{]1..2}2@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/brace-expansion/003-it-does-not-expand-braces-3 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout "{1..2}"{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}1@[{]1..2}2@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/brace-expansion/001-it-does-not-expand-braces-1 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_on_stdout "{1..2}"

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/bracket-expansion/002-it-works-2 (FAILED)

  Description:
  The purpose of this test is to check that an argument made with quoted and unquoted parts results in bracket pattern expansion.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout ["a"bc"def"gh]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `b@`
  FAILURE    expected_to match_regex `c@`
  FAILURE    expected_to match_regex `d@`
  FAILURE    expected_to match_regex `e@`
  FAILURE    expected_to match_regex `f@`
  FAILURE    expected_to match_regex `g@`
  FAILURE    expected_to match_regex `h@`
  SUCCESS    expected_to_not match_regex `bc`
  SUCCESS    expected_to_not match_regex `def`
  SUCCESS    expected_to_not match_regex `gh`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/globbing/bracket-expansion/001-it-works-1 (FAILED)

  Description:
  The purpose of this test is to check that an argument made with quoted and unquoted parts results in bracket pattern expansion.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout ["a"]

  STDOUT:
  SUCCESS    expected_to_not match_regex `[[]a]@`
  FAILURE    expected_to match_regex `^a@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/escaping/004-it-results-in-error (FAILED)

  Description:
  The purpose of this test is to check that using backslash `\\` before the closing double-quote `"` does result in syntax error.

  STDIN:
   1: ./write_on_stdout "TOKEN201803301333\"

  STDOUT:
  SUCCESS    expected_to_not match_regex `^TOKEN201803301333$`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/escaping/003-escape-double-quote-3 (FAILED)

  Description:
  The purpose of this test is to check that a double-quote `"` may be preserved when it is preceded by a backslash `\\`.

  STDIN:
   1: ./write_on_stdout "\""

  STDOUT:
  FAILURE    expected_to match_regex `^"$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/escaping/001-escape-double-quote-1 (FAILED)

  Description:
  The purpose of this test is to check that a double-quote `"` may be preserved when it is preceded by a backslash `\\`.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333\"TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333"TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/escaping/002-escape-double-quote-2 (FAILED)

  Description:
  The purpose of this test is to check that a double-quote `"` may be preserved when it is preceded by a backslash `\\`.

  STDIN:
   1: ./write_on_stdout "TOKEN201803301333 \" TOKEN201803301333"

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333 ` TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/mixed/escaping/005-it-does-not-escape-double-quote (FAILED)

  Description:
  The purpose of this test is to check that using two backslashes `\\` before the symbol double-quote `"` does not result in escaped inhibitors.

  STDIN:
   1: ./write_on_stdout \\"TOKEN201803301333\\"

  STDOUT:
  FAILURE    expected_to match_regex `^\\TOKEN201803301333\\$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/003-first-argument-inhibited (FAILED)

  Description:
  The purpose of this test is to check that the shell implementation has no special case for the first argument.

  STDIN:
   1: "./write_on_stdout_and_stderr" TOKEN201803301333_STDOUT TOKEN201803301333_STDERR

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_STDOUT`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_STDERR`
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/004-multiline-1 (FAILED)

  Description:
  The purpose of this test is to check that closing double quote may be done on a different line.

  STDIN:
   1: ./write_on_stdout "
   2: TOKEN201803301333_FIRST
   3: TOKEN201803301333_SECOND
   4: TOKEN201803301333_THIRD
   5: "

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_FIRST$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_SECOND$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_THIRD$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/001-it-works (FAILED)

  Description:
  The purpose of this test is to check that using the symbol double quote `"` does not result in error.

  STDIN:
   1: ./write_on_stdout "SIMPLE TEXT WITH SPACES"

  STDOUT:
  FAILURE    expected_to match_regex `SIMPLE TEXT WITH SPACES`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/002-concatenated-strings (FAILED)

  Description:
  The purpose of this test is to check that a mixed argument with multiple inhibited parts is considered as a single argument.

  STDIN:
   1: ./write_on_stdout_and_stderr A"B"CDEF"GHIJ""KLMNO" "P"QRS"T""U""V"WXYZ

  STDOUT:
  FAILURE    expected_to match_regex `ABCDEFGHIJKLMNO`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `PQRSTUVWXYZ`
  (no output)

----------------------------------------------------------------

42sh/quoting/double-quotes/005-multiline-2 (FAILED)

  Description:
  The purpose of this test is to check that closing double quote may be done on a different line.

  STDIN:
   1: ./write_on_stdout_and_stderr "
   2: "TOKEN201803301333"_FIRST
   3: TOKEN201803301333_SECOND" "TOKEN201803301333_THIRD
   4: TOKEN201803301333_FOU"RT"H
   5: "

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_FIRST$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_SECOND$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^TOKEN201803301333_THIRD$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_FOURTH$`
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/variable-expansion/001-expansion-disabled (FAILED)

  Description:
  The purpose of this test is to check that variable expansion is not processed within simple quotes.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: ./write_on_stdout '[$]TOKEN201803301333_NAME'

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/brace-expansion/002-it-does-not-expand-braces-2 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout {1..2}'{1..2}'

  STDOUT:
  FAILURE    expected_to match_regex `1[{]1..2}@2[{]1..2}@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/brace-expansion/005-it-does-not-expand-braces-5 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout '{1..2}' {1..2} '{1..2}' '{1..2}'

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}@1@2@[{]1..2}@[{]1..2}@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/brace-expansion/004-it-does-not-expand-braces-4 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout '{1..2}'{1..2}'{1..2}'{1..2}'{1..2}'{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}1[{]1..2}1[{]1..2}1@[{]1..2}1[{]1..2}1[{]1..2}2@[{]1..2}1[{]1..2}2[{]1..2}1@[{]1..2}1[{]1..2}2[{]1..2}2@[{]1..2}2[{]1..2}1[{]1..2}1@[{]1..2}2[{]1..2}1[{]1..2}2@[{]1..2}2[{]1..2}2[{]1..2}1@[{]1..2}2[{]1..2}2[{]1..2}2@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/brace-expansion/003-it-does-not-expand-braces-3 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_all_arguments_on_stdout '{1..2}'{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}1@[{]1..2}2@`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/brace-expansion/001-it-does-not-expand-braces-1 (FAILED)

  Description:
  The purpose of this test is to check that braces expansion is not processed within quoted part of the command line.

  STDIN:
   1: ./write_on_stdout '{1..2}'

  STDOUT:
  FAILURE    expected_to match_regex `[{]1..2}`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/bracket-expansion/002-it-works-2 (FAILED)

  Description:
  The purpose of this test is to check that an argument made with quoted and unquoted parts results in bracket pattern expansion.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout ['a'bc'def'gh]

  STDOUT:
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `b@`
  FAILURE    expected_to match_regex `c@`
  FAILURE    expected_to match_regex `d@`
  FAILURE    expected_to match_regex `e@`
  FAILURE    expected_to match_regex `f@`
  FAILURE    expected_to match_regex `g@`
  FAILURE    expected_to match_regex `h@`
  SUCCESS    expected_to_not match_regex `bc`
  SUCCESS    expected_to_not match_regex `def`
  SUCCESS    expected_to_not match_regex `gh`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/globbing/bracket-expansion/001-it-works-1 (FAILED)

  Description:
  The purpose of this test is to check that an argument made with quoted and unquoted parts results in bracket pattern expansion.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout ['a']

  STDOUT:
  SUCCESS    expected_to_not match_regex `[[]a]@`
  FAILURE    expected_to match_regex `^a@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/escaping/005-it-does-not-escape-simple-quote-2 (FAILED)

  Description:
  The purpose of this test is to check that using two backslashes `\\` before the symbol simple-quote `'` does not result in escaped inhibitors.

  STDIN:
   1: ./write_on_stdout \\'TOKEN201803301333\\'

  STDOUT:
  FAILURE    expected_to match_regex `^\\TOKEN201803301333\$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/escaping/002-escape-simple-quote-2 (FAILED)

  Description:
  The purpose of this test is to check that a simple-quote `'` may be preserved when it is preceded by a backslash `\\`.

  STDIN:
   1: ./write_on_stdout_and_stderr \'TOKEN201803301333_STDOUT TOKEN201803301333_STDERR\'

  STDOUT:
  FAILURE    expected_to match_regex `^'TOKEN201803301333_STDOUT$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^TOKEN201803301333_STDERR'$`
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/escaping/003-escape-simple-quote-3 (FAILED)

  Description:
  The purpose of this test is to check that a simple-quote `'` may be preserved when it is preceded by a backslash `\\`.

  STDIN:
   1: ./write_on_stdout '\'

  STDOUT:
  FAILURE    expected_to match_regex `^\\$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/mixed/escaping/001-escape-simple-quote-1 (FAILED)

  Description:
  The purpose of this test is to check that a simple-quote `'` may be preserved when it is preceded by a backslash `\\`.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333\'TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333'TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/003-first-argument-inhibited (FAILED)

  Description:
  The purpose of this test is to check that the shell implementation has no special case for the first argument.

  STDIN:
   1: './write_on_stdout_and_stderr' TOKEN201803301333_STDOUT TOKEN201803301333_STDERR

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_STDOUT`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_STDERR`
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/004-multiline-1 (FAILED)

  Description:
  The purpose of this test is to check that closing double quote may be done on a different line.

  STDIN:
   1: ./write_on_stdout '
   2: TOKEN201803301333_FIRST
   3: TOKEN201803301333_SECOND
   4: TOKEN201803301333_THIRD
   5: '

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_FIRST$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_SECOND$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_THIRD$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/001-it-works (FAILED)

  Description:
  The purpose of this test is to check that using the symbol simple quote `'` does not result in error.

  STDIN:
   1: ./write_on_stdout 'SIMPLE TEXT WITH SPACES'

  STDOUT:
  FAILURE    expected_to match_regex `SIMPLE TEXT WITH SPACES`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/002-concatenated-strings (FAILED)

  Description:
  The purpose of this test is to check that a mixed argument with multiple inhibited parts is considered as a single argument.

  STDIN:
   1: ./write_on_stdout_and_stderr A'B'CDEF'GHIJ''KLMNO' 'P'QRS'T''U''V'WXYZ

  STDOUT:
  FAILURE    expected_to match_regex `ABCDEFGHIJKLMNO`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `PQRSTUVWXYZ`
  (no output)

----------------------------------------------------------------

42sh/quoting/simple-quotes/005-multiline-2 (FAILED)

  Description:
  The purpose of this test is to check that closing double quote may be done on a different line.

  STDIN:
   1: ./write_on_stdout_and_stderr '
   2: 'TOKEN201803301333'_FIRST
   3: TOKEN201803301333_SECOND' 'TOKEN201803301333_THIRD
   4: TOKEN201803301333_FOU'RT'H
   5: '

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_FIRST$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_SECOND$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `^TOKEN201803301333_THIRD$`
  FAILURE    expected_to match_regex `^TOKEN201803301333_FOURTH$`
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/variable-expansion/001-escape-variable-1 (FAILED)

  Description:
  The purpose of this test is to check that using a backslash `\\` before the symbol of variable expansion `$` does not result in variable expansion.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: ./write_on_stdout \$TOKEN201803301333_NAME

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_VALUE`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/variable-expansion/002-it-does-not-escape-variable (FAILED)

  Description:
  The purpose of this test is to check that using two backslashes `\\` before the symbol of variable expansion `$` does result in variable expansion.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: ./write_on_stdout \\$TOKEN201803301333_NAME

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_NAME`
  FAILURE    expected_to match_regex `TOKEN201803301333_VALUE`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/variable-expansion/003-escape-variable-2 (FAILED)

  Description:
  The purpose of this test is to check that using three backslashes `\\` before the symbol of variable expansion `$` does not result in variable expansion.

  Before test:
   1: export "TOKEN201803301333_NAME=TOKEN201803301333_VALUE"

  STDIN:
   1: ./write_on_stdout \\\$TOKEN201803301333_NAME

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_NAME`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_VALUE`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/globbing/brace-expansion/002-it-expands-braces-1 (FAILED)

  Description:
  The purpose of this test is to check that using multiple escape characters `\\` results in a good behavior with the brace expansion.

  STDIN:
   1: ./write_all_arguments_on_stdout \\{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `^\\1@\\2@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/globbing/brace-expansion/003-it-expands-braces-2 (FAILED)

  Description:
  The purpose of this test is to check that using multiple escape characters `\\` results in a good behavior with the brace expansion.

  STDIN:
   1: ./write_all_arguments_on_stdout \\\{1..2} \\\\{1..2} \\\\\{1..2} \\\\\\{1..2}

  STDOUT:
  FAILURE    expected_to match_regex `^\\[{]1..2}@\1@\2@\[{]1..2}@\\\1@\\\2@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/globbing/brace-expansion/001-it-does-not-expand-braces-1 (FAILED)

  Description:
  The purpose of this test is to check that escaping braces does not result in an expansion process.

  STDIN:
   1: ./write_all_arguments_on_stdout \{1..2} {1\..2} {1.\.2} {1..2\}

  STDOUT:
  FAILURE    expected_to match_regex `^[{]1..2}@[{]1..2}@[{]1..2}@[{]1..2}@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/globbing/bracket-expansion/002-escaped-inversion-mark (FAILED)

  Description:
  The purpose of this test is to check that the brackets expansion works with an inversion mark `!` or `^` as pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'd' 'e' 'f' '!' '^'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [\!abc]
   2: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [\^abc]

  STDOUT:
  FAILURE    expected_to match_regex `!@`
  FAILURE    expected_to match_regex `[\\^]@`
  FAILURE    expected_to match_regex `a@`
  FAILURE    expected_to match_regex `b@`
  FAILURE    expected_to match_regex `c@`
  SUCCESS    expected_to_not match_regex `d@`
  SUCCESS    expected_to_not match_regex `e@`
  SUCCESS    expected_to_not match_regex `f@`
  WARNING    might match_regex `^!@a@b@c@$`
  WARNING    might match_regex `^[\\^]@a@b@c@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/globbing/bracket-expansion/001-it-does-not-expand-brackets (FAILED)

  Description:
  The purpose of this test is to check that escaping brackets does not result in an expansion process.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout \[abc] [abc\] \[abc\]

  STDOUT:
  FAILURE    expected_to match_regex `^[[]abc]@[[]abc]@[[]abc]@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/mixed/globbing/bracket-expansion/003-it-takes-escaped-bracket-as-pattern-character (FAILED)

  Description:
  The purpose of this test is to check that a closing bracket ']' may be escaped in a backet expansion pattern.

  Before test:
   1: rm -rf "./test_globbing"
   2: mkdir "./test_globbing"
   3: cd "./test_globbing"
   4: touch 'a' 'b' 'c' 'd' 'e' 'f' ']'

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [abc\]def]
   2: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [abc\\\]def]
   3: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [abc\\\\\]def]
   4: /home/pi/42ShellTester/tmp/write_all_arguments_on_stdout [abc\\\\\\\]def]

  STDOUT:
  FAILURE    expected_to match_regex `a@` 4 times
  FAILURE    expected_to match_regex `b@` 4 times
  FAILURE    expected_to match_regex `c@` 4 times
  FAILURE    expected_to match_regex `]@` 4 times
  FAILURE    expected_to match_regex `d@` 4 times
  FAILURE    expected_to match_regex `e@` 4 times
  FAILURE    expected_to match_regex `f@` 4 times
  SUCCESS    expected_to_not match_regex `def`
  WARNING    might match_regex `^]@a@b@c@d@e@f@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/003-escape-single-character-3 (FAILED)

  Description:
  The purpose of this test is to check that using a backslash `\\` outside enclosing characters double-quote `"` or signle-quote `'` results in a preserved following character.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333\\\TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333\\TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/002-escape-single-character-2 (FAILED)

  Description:
  The purpose of this test is to check that using a backslash `\\` outside enclosing characters double-quote `"` or signle-quote `'` results in a preserved following character.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333\\TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333\\TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/004-escape-single-character-4 (FAILED)

  Description:
  The purpose of this test is to check that using a backslash `\\` outside enclosing characters double-quote `"` or signle-quote `'` results in a preserved following character.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333\\\\TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333\TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/005-escape-single-character-5 (FAILED)

  Description:
  The purpose of this test is to check that using a backslash `\\` outside enclosing characters double-quote `"` or signle-quote `'` results in a preserved following character.

  STDIN:
   1: ./write_on_stdout TEST4\041TEST

  STDOUT:
  FAILURE    expected_to match_regex `^TEST4041TEST$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

42sh/escaping/001-escape-single-character-1 (FAILED)

  Description:
  The purpose of this test is to check that using a backslash `\\` outside enclosing characters double-quote `"` or signle-quote `'` results in a preserved following character.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333\TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

21sh/pipe/004-without-surrounding-whitespaces (FAILED)

  Description:
  A pipe character `|` that is not enclosed in double-quotes is interpreted as a pipe separator even if it is closely placed to the next and previous command fields.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333|./read_on_stdin

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333@$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

21sh/pipe/003-many-chained-pipes (FAILED)

  Description:
  One line with many piped commands.
  The first process write a token on STDOUT and another on STDERR, then the others read on STDIN and write lines suffixed with the character '@' (similar to `cat -e`). The full command line results in an output suffixed with ten characters '@@@@@@@@@@'.

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin | ./read_on_stdin

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_stdout@@@@@@@@@@$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr$`
  (no output)

----------------------------------------------------------------

21sh/pipe/006-exit-status (FAILED)

  Description:
  The purpose of this test is to check that the exit status of a pipeline command is the same as the last piped process.

  STDIN:
   1: ./sleep_and_exit_with_status 1 21 | ./exit_with_status 42

  STDOUT:
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `42`

----------------------------------------------------------------

21sh/pipe/005-asynchronous (FAILED)

  Description:
  The purpose of this test is to check that the Shell waits for all the commands specified in a pipeline to complete before looking after the next command line. In this test, the first command of the pipeline takes a longer time to complete than the next one, so that the outputs should appear in a reverse order. The Shell should wait for the two processes to complete and then launch the second command line.

  STDIN:
   1: ./sleep_and_write_on_stderr 1 TOKEN201803301333_FIRST | ./sleep_and_write_on_stderr 0 TOKEN201803301333_SECOND
   2: ./sleep_and_write_on_stderr 0 TOKEN201803301333_LAST

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_SECONDTOKEN201803301333_FIRSTTOKEN201803301333_LAST`
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

21sh/pipe/002-chained-pipes (FAILED)

  Description:
  Simple test with two piped commands.
  The first process write a token on STDOUT and another on STDERR, then the second one read on STDIN and write lines suffixed with the character '@' (similar to `cat -e`). The third one does the same as the second one, so that lines are suffixed with '@@'.

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr | ./read_on_stdin | ./read_on_stdin

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_stdout@@$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr$`
  (no output)

----------------------------------------------------------------

21sh/pipe/001-single-pipe (FAILED)

  Description:
  Simple test with one piped command.
  The first process write a token on STDOUT and another on STDERR, then the second one read on STDIN and write lines suffixed with the character '@' (similar to `cat -e`).

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr | ./read_on_stdin

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_stdout@$`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr$`
  (no output)

----------------------------------------------------------------

21sh/separators/semicolon/002-n-commands-sequentially (FAILED)

  Description:
  The purpose of this test is to check that the semicolon separator `;` makes multiple inline commands to be executed sequentially.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333_FIRST ; ./write_on_stdout TOKEN201803301333_SECOND ; ./write_on_stdout TOKEN201803301333_THIRD ; ./write_on_stdout TOKEN201803301333_FOURTH

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST$`
  FAILURE    expected_to match_regex `TOKEN201803301333_SECOND$`
  FAILURE    expected_to match_regex `TOKEN201803301333_THIRD$`
  FAILURE    expected_to match_regex `TOKEN201803301333_FOURTH$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

21sh/separators/semicolon/004-parse-error-empty-command (FAILED)

  Description:
  The purpose of this test is to check that using the semicolon separator `;` without any command results in error.

  STDIN:
   1: ;

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Pp]arse|[Ss]yntax) error`
  (no output)

----------------------------------------------------------------

21sh/separators/semicolon/003-parse-error-empty-inline-command (FAILED)

  Description:
  The purpose of this test is to check that using the simicolon separator `;` with empty commands results in error.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333 ; ; ./exit_with_status 42

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

  MISC:
  SUCCESS    expected_to_not exit_with_status `42`
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

21sh/separators/semicolon/001-two-commands-sequentially (FAILED)

  Description:
  The purpose of this test is to check that the semicolon separator `;` makes two inline commands to be executed sequentially.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333_FIRST ; ./write_on_stdout TOKEN201803301333_SECOND

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST$`
  FAILURE    expected_to match_regex `TOKEN201803301333_SECOND$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

21sh/misc/001-no-prompt-in-non-interactive-mode (FAILED)

  Description:
  A non-interactive Shell should not output a prompt. All the test suite runs the Shell in a non-interactive way so that `isatty()` returns `0`. This test is the only one that take it into account so that you can succeed the rest of the suite.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333

  STDOUT:
  FAILURE    expected_to have_nb_of_lines 1
  FAILURE    expected_to match_regex `^TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

21sh/misc/002-simple-command-line (FAILED)

  Description:
  The purpose of this test is to check that the Shell is able to execute a simple command line that contains separators `;`, pipes `|`, and a right redirection `>`.

  Before test:
   1: rm -rf "./size"
   2: rm -rf "TOKEN201803301333"
   3: echo '^'$(echo TOKEN201803301333_FILE_TOKEN201803301333_STDOUT | wc -c)'$' > "./size"

  STDIN:
   1: mkdir TOKEN201803301333 ; cd TOKEN201803301333 ; touch TOKEN201803301333_FILE ; ls -1 ; ls | cat | wc -c > TOKEN201803301333_STDOUT ; cat TOKEN201803301333_STDOUT

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FILE$`
  FAILURE    expected_to match_each_regex_of_file `./size`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

21sh/redirections/outputs/truncating/multiple/003-together-stderr-first (FAILED)

  Description:
  A right redirection can be associated to the twice outputs by using `M>&N`, that means `redirect M to where N is redirected`.
  In this test the standard error is specified first.

  Before test:
   1: rm -f new_file_stderr_and_stdout

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_1 TOKEN201803301333_2 2>new_file_stderr_and_stdout 1>&2

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_1$`
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_2$`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/multiple/004-together (FAILED)

  Description:
  A right redirection can be associated to the twice outputs by using `&>...`, that means `redirect stdout and stderr to ...`.

  Before test:
   1: rm -f "new_file_stderr_and_stdout"

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_1 TOKEN201803301333_2 &>new_file_stderr_and_stdout

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_1$`
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_2$`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/multiple/001-separately (FAILED)

  Description:
  A different right redirection may be specified for each output.

  Before test:
   1: rm -f "new_file_stderr"
   2: rm -f "new_file_stdout"

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_1 TOKEN201803301333_2 1>new_file_stdout 2>new_file_stderr

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file_stdout` matching_regex `TOKEN201803301333_1$`
  FAILURE    expected_to create_file `new_file_stderr` matching_regex `TOKEN201803301333_2$`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/multiple/005-together-with-whitespaces (FAILED)

  Description:
  A right redirection can be associated to the twice outputs by using `&>...`, that means `redirect stdout and stderr to ...`.
  In this test, we specify the file name in a separate field.

  Before test:
   1: rm -f new_file_stderr_and_stdout

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_1 TOKEN201803301333_2 &>	  	new_file_stderr_and_stdout

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_1$`
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_2$`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/multiple/002-together-stdout-first (FAILED)

  Description:
  A right redirection can be associated to the twice outputs by using `M>&N`, that means `redirect M to where N is redirected`.
  In this test the standard output is specified first.

  Before test:
   1: rm -f new_file_stderr_and_stdout

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_1 TOKEN201803301333_2 1>new_file_stderr_and_stdout 2>&1

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_1`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_2`
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_1$`
  FAILURE    expected_to create_file `new_file_stderr_and_stdout` matching_regex `TOKEN201803301333_2$`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/stderr/001-works (FAILED)

  Description:
  The purpose of this test is to check that redirecting the standard error STDERR to a file `2>` works. In this test, the binary writes a token on each standard and error output, so that only the STDOUT is outputted and STDERR is written in a file `new_file_stderr`.

  Before test:
   1: rm -f "./new_file_stderr"

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_STDOUT TOKEN201803301333_STDERR 2>new_file_stderr

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_STDOUT`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_STDERR`
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file_stderr` matching_regex `TOKEN201803301333_STDERR`
  FAILURE    expected_to create_file `new_file_stderr` with_nb_of_lines 1

----------------------------------------------------------------

21sh/redirections/outputs/truncating/002-truncates-file-if-exists (FAILED)

  Description:
  The right redirection `>` opens the file with the oflag `O_TRUNC` so that the file size is truncated to 0 before writing in it.

  Before test:
   1: ./write_on_stdout TOKEN201803301333_first >truncated_file

  STDIN:
   1: ./write_on_stdout TOKEN201803301333_second >truncated_file

  STDOUT:
  SUCCESS    expected_to_not match_regex TOKEN201803301333_second
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to create_file `truncated_file` matching_regex `TOKEN201803301333_second`
  FAILURE    expected_to create_file `truncated_file` not_matching_regex `TOKEN201803301333_first`
  SUCCESS    expected_to create_file `truncated_file` with_nb_of_lines `1`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/003-whitespace-before-filename (FAILED)

  Description:
  The file name for a right redirection can be specified closely to the character `>` or in a separated field.

  Before test:
   1: rm -f "new_file"

  STDIN:
   1: ./write_on_stdout TOKEN201803301333 > new_file

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file` matching_regex `TOKEN201803301333`
  FAILURE    expected_to create_file `new_file` with_nb_of_lines `1`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/001-creates-file-if-not-exits (FAILED)

  Description:
  The right redirection `>` opens the file with the oflag `O_CREAT` so that the file is created if it does not exists.

  Before test:
   1: rm -f new_file

  STDIN:
   1: ./write_on_stdout TOKEN201803301333 >new_file

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_file` matching_regex `TOKEN201803301333`
  FAILURE    expected_to create_file `new_file` with_nb_of_lines `1`

----------------------------------------------------------------

21sh/redirections/outputs/truncating/stdout/001-with-explicit-fd (FAILED)

  Description:
  The purpose of this test is to check if '1>' redirect STDIN to a file.
  We are using echo with one argument. The output should NOT return anything on the standard output.

  Before test:
   1: rm -f new_file

  STDIN:
   1: /bin/echo TOKEN1 1>new_file

  STDOUT:
  SUCCESS    expected_to_not match_regex TOKEN1
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to create_file new_file matching_regex TOKEN1
  FAILURE    expected_to create_file new_file with_nb_of_lines 1

----------------------------------------------------------------

21sh/redirections/outputs/appending/multiple/001-append-twice-separately (FAILED)

  Description:
  A double right redirection opens the file with the oflag `O_APPEND`, so that its size is not truncated to 0 and output is written at the end of file. If the file does not exist, it is created.
  In this test, each output is appended to different files.

  Before test:
   1: ./write_on_stdout "TOKEN201803301333_stdout_first" >append_file_stdout
   2: ./write_on_stdout "TOKEN201803301333_stderr_first" >append_file_stderr

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout_second TOKEN201803301333_stderr_second 1>>append_file_stdout 2>>append_file_stderr

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stdout_second`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stderr_second`
  (no output)

  MISC:
  SUCCESS    expected_to create_file `append_file_stdout` matching_regex `TOKEN201803301333_stdout_first$`
  FAILURE    expected_to create_file `append_file_stdout` matching_regex `TOKEN201803301333_stdout_second$`
  SUCCESS    expected_to create_file `append_file_stderr` matching_regex `TOKEN201803301333_stderr_first$`
  FAILURE    expected_to create_file `append_file_stderr` matching_regex `TOKEN201803301333_stderr_second$`

----------------------------------------------------------------

21sh/redirections/outputs/appending/001-append-default-to-file (FAILED)

  Description:
  A double right redirection opens the file with the oflag `O_APPEND`, so that its size is not truncated to 0 and output is written at the end of file. If the file does not exist, it is created.
  In this test, the output to be redirected is not specified so that the standard output is appended to the file.

  Before test:
   1: ./write_on_stdout "TOKEN201803301333_first" >append_file_default

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_default TOKEN201803301333_stderr >>append_file_default

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_default`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr`
  (no output)

  MISC:
  SUCCESS    expected_to create_file `append_file_default` matching_regex `TOKEN201803301333_first`
  FAILURE    expected_to create_file `append_file_default` matching_regex `TOKEN201803301333_default`

----------------------------------------------------------------

21sh/redirections/outputs/appending/002-append-stdout-to-file (FAILED)

  Description:
  A double right redirection opens the file with the oflag `O_APPEND`, so that its size is not truncated to 0 and output is written at the end of file. If the file does not exist, it is created.
  In this test, the standard output is appended to the file.

  Before test:
   1: ./write_on_stdout "TOKEN201803301333_first" >append_file_stdout

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr 1>>append_file_stdout

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr`
  (no output)

  MISC:
  SUCCESS    expected_to create_file `append_file_stdout` matching_regex `TOKEN201803301333_first`
  FAILURE    expected_to create_file `append_file_stdout` matching_regex `TOKEN201803301333_stdout`

----------------------------------------------------------------

21sh/redirections/outputs/appending/003-append-stderr-to-file (FAILED)

  Description:
  A double right redirection opens the file with the oflag `O_APPEND`, so that its size is not truncated to 0 and output is written at the end of file. If the file does not exist, it is created.
  In this test, the standard error is appended to the file.

  Before test:
   1: ./write_on_stdout "TOKEN201803301333_first" >append_file_stderr

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr 2>>append_file_stderr

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_stdout`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stderr`
  (no output)

  MISC:
  SUCCESS    expected_to create_file `append_file_stderr` matching_regex `TOKEN201803301333_first`
  FAILURE    expected_to create_file `append_file_stderr` matching_regex `TOKEN201803301333_stderr`

----------------------------------------------------------------

21sh/redirections/outputs/closing/001-close-default-output (FAILED)

  Description:
  Not specifying which output to close makes the default standard output to be closed (`>&-` is similar to `1>&-`).
  Closing the standard output has the same behavior as redirecting to `/dev/null`.

  Before test:
   1: rm -f "-"

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr >&-

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr`
  (no output)

  MISC:
  SUCCESS    expected_to_not create_file `-`

----------------------------------------------------------------

21sh/redirections/outputs/closing/002-close-stdout (FAILED)

  Description:
  Closing the standard output has the same behavior as redirecting to `/dev/null` (e.g. `ls 1>/dev/null`).

  Before test:
   1: rm -f "-"

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr 1>&-

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stdout`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_stderr`
  (no output)

  MISC:
  SUCCESS    expected_to_not create_file `-`

----------------------------------------------------------------

21sh/redirections/outputs/closing/003-close-stderr (FAILED)

  Description:
  Closing the standard error has the same behavior as redirecting to `/dev/null` (e.g. `ls 2>/dev/null`).

  Before test:
   1: rm -f "-"

  STDIN:
   1: ./write_on_stdout_and_stderr TOKEN201803301333_stdout TOKEN201803301333_stderr 2>&-

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_stdout`
  (no output)

  STDERR:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_stderr`
  (no output)

  MISC:
  SUCCESS    expected_to_not create_file `-`

----------------------------------------------------------------

21sh/redirections/outputs/touching/001-works (FAILED)

  Description:
  The purpose of this test is to check that using the right redirection `>` without any command results in the creation of an empty file (same effect as `touch`).

  Before test:
   1: rm -f "./new_empty_file"

  STDIN:
   1: >new_empty_file

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to create_file `new_empty_file`
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

21sh/redirections/inputs/005-no-such-file (FAILED)

  Description:
  The purpose of this test is to check that using a wrong path within the STDIN redirection `<` results in an error.

  Before test:
   1: rm -f "./no_such_file"

  STDIN:
   1: ./read_on_stdin <no_such_file

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Nn]o such file or directory`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

21sh/redirections/inputs/001-close-stdin (FAILED)

  Description:
  The purpose of this test is to check that using the closing operator `&-` within the STDIN redirection `<` results in a closed standard input, so that `read(2)` results in a read error.

  Before test:
   1: rm -f ./read_on_stdin
   2: gcc -Wall -Werror -Wextra "/home/pi/42ShellTester/support/read-on-stdin/main.c" -o ./read_on_stdin

  STDIN:
   1: ./read_on_stdin <&-

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `STDIN READ ERROR$`
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `1`

----------------------------------------------------------------

21sh/redirections/inputs/004-absolute-path (FAILED)

  Description:
  The purpose of this test is to check that using an absolute path to a file within the STDIN redirection `<` results in the ability of the child process to read on this file through the file descriptor STDIN.

  Before test:
   1: echo "TOKEN201803301333_LINE_1" > simple_text_file
   2: echo "TOKEN201803301333_LINE_2" >> simple_text_file
   3: echo "TOKEN201803301333_LINE_3" >> simple_text_file

  STDIN:
   1: ./read_on_stdin </home/pi/42ShellTester/tmp/simple_text_file

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_1`
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_2`
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_3`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

21sh/redirections/inputs/003-filename-with-whitespaces (FAILED)

  Description:
  The purpose of this test is to check that using a file path `simple_text_file` within the STDIN redirection `<` results in the ability of the child process to read on this file through the file descriptor STDIN.
  The file path is specified in a separated field.

  Before test:
   1: echo "TOKEN201803301333_LINE_1" > simple_text_file
   2: echo "TOKEN201803301333_LINE_2" >> simple_text_file
   3: echo "TOKEN201803301333_LINE_3" >> simple_text_file

  STDIN:
   1: ./read_on_stdin < 	 simple_text_file

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_1`
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_2`
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_3`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

21sh/redirections/inputs/002-filename (FAILED)

  Description:
  The purpose of this test is to check that using a file path `simple_text_file` within the STDIN redirection `<` results in the ability of the child process to read on this file through the file descriptor STDIN.

  Before test:
   1: echo "TOKEN201803301333_LINE_1" > simple_text_file
   2: echo "TOKEN201803301333_LINE_2" >> simple_text_file
   3: echo "TOKEN201803301333_LINE_3" >> simple_text_file

  STDIN:
   1: ./read_on_stdin <simple_text_file

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_1`
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_2`
  FAILURE    expected_to match_regex `TOKEN201803301333_LINE_3`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/env/errors/001-command-not-found (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `env` with an invalid binary as argument results in an error and failure exit status.

  Before test:
   1: rm -f "./invalid_binary"

  STDIN:
   1: env ./invalid_binary

  STDOUT:
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Cc]ommand not found`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/env/errors/002-illegal-option (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `env` with an invalid option results in an error and failure exit status.

  Before test:
   1: rm -f -- "-w"

  STDIN:
   1: env -w

  STDOUT:
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Ii]nvalid|[Ii]llegal) (option|argument)`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/env/003-ignore-environment (FAILED)

  Description:
  The purpose of this test is to check that using the option `-i` with the builtin `env` results in an empty environment sent to the given command.

  STDIN:
   1: env -i ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TOTAL ENVIRONMENT VARIABLES: 0`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/env/001-env-same-value-as-parent (FAILED)

  Description:
  The purpose of this test is to check if your shell is using a copy of his parent environment as environment.
  We are using a copy of the environment variable before starting your shell and the command env from your shell.

  Before test:
   1: # storing all environment variables except OLDPWD
   2: env | awk 'BEGIN {FS="="} $0 !~ /^OLDPWD/ {print $1"="}' > "./stored_env"

  STDIN:
   1: env

  STDOUT:
  FAILURE    expected_to match_each_regex_of_file `./stored_env`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/env/multiple-options/001-ignore-environment-and-set-variable (FAILED)

  Description:
  The purpose of this test is to check that `env -i` works if we use a second argument to set an environment variable, we are also checking if this command unset environments variables for a given binary.

  STDIN:
   1: env -i TESTVARIABLE=TOKEN201803301333 ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TESTVARIABLE=TOKEN201803301333`
  FAILURE    expected_to match_regex `TOTAL ENVIRONMENT VARIABLES: 1`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/env/005-set-variables (FAILED)

  Description:
  The purpose of this test is to check that the builtin `env` can modify or set multiple environment variables before executing the given command.

  Before test:
   1: export VARTEST1="OLD_VALUE"

  STDIN:
   1: env VARTEST1=TOKEN201803301333_1 VARTEST2=TOKEN201803301333_2 VARTEST3=TOKEN201803301333_3 ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `VARTEST1=TOKEN201803301333_1`
  FAILURE    expected_to match_regex `VARTEST2=TOKEN201803301333_2`
  FAILURE    expected_to match_regex `VARTEST3=TOKEN201803301333_3`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/env/002-env-check-usefull-var (FAILED)

  Description:
  The purpose of this test is to check that basic environment variables are well stored.
  We add a special variable to the environment before the execution.

  Before test:
   1: export TEST_42SHTEST="TOKEN201803301333"

  STDIN:
   1: env

  STDOUT:
  FAILURE    expected_to match_regex `PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games`
  FAILURE    expected_to match_regex `PWD=${PWD}`
  FAILURE    expected_to match_regex `HOME=/home/pi`
  FAILURE    expected_to match_regex `TEST_42SHTEST=TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/setenv/002-add-new-variable (FAILED)

  Description:
  The purpose of this test is to check that the builtin `setenv` (or `export`) can add a new variable to the environment, either with the syntax `setenv KEY VALUE` or with `setenv KEY=VALUE`.

  Before test:
   1: unset "TESTVAR1"

  STDIN:
   1: setenv TESTVAR1 VALUE_TOKEN201803301333
   2: ./display_env
   3: 
   4: setenv TESTVAR1=VALUE_TOKEN201803301333
   5: ./display_env
   6: 
   7: export TESTVAR1=VALUE_TOKEN201803301333
   8: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TESTVAR1=VALUE_TOKEN201803301333`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

minishell/builtins/setenv/005-add-and-set-multiple-variables (FAILED)

  Description:
  The purpose of this test is to check that the builtin `setenv` (or `export`) can add multiples variables into the environment, either with the syntax `setenv KEY VALUE` or with `setenv KEY=VALUE`.

  Before test:
   1: unset "TESTVAR1"
   2: unset "TESTVAR2"
   3: unset "TESTVAR3"
   4: unset "TESTVAR4"
   5: unset "TESTVAR5"
   6: unset "TESTVAR6"
   7: unset "TESTVAR7"
   8: unset "TESTVAR8"
   9: unset "TESTVAR9"
  10: unset "TESTVAR10"
  11: 
  12: export "TEST2VAR1=OLD_TOKEN201803301333_1"
  13: export "TEST2VAR2=OLD_TOKEN201803301333_2"
  14: export "TEST2VAR3=OLD_TOKEN201803301333_3"
  15: export "TEST2VAR4=OLD_TOKEN201803301333_4"
  16: export "TEST2VAR5=OLD_TOKEN201803301333_5"
  17: export "TEST2VAR6=OLD_TOKEN201803301333_6"
  18: export "TEST2VAR7=OLD_TOKEN201803301333_7"
  19: export "TEST2VAR8=OLD_TOKEN201803301333_8"
  20: export "TEST2VAR9=OLD_TOKEN201803301333_9"
  21: export "TEST2VAR10=OLD_TOKEN201803301333_10"

  STDIN:
   1: setenv TESTVAR1 VALUE_TOKEN201803301333_1
   2: setenv TEST2VAR1 VALUE_TOKEN201803301333_1
   3: setenv TESTVAR2 VALUE_TOKEN201803301333_2
   4: setenv TEST2VAR2 VALUE_TOKEN201803301333_2
   5: setenv TESTVAR3 VALUE_TOKEN201803301333_3
   6: setenv TEST2VAR3 VALUE_TOKEN201803301333_3
   7: setenv TESTVAR4 VALUE_TOKEN201803301333_4
   8: setenv TEST2VAR4 VALUE_TOKEN201803301333_4
   9: setenv TESTVAR5 VALUE_TOKEN201803301333_5
  10: setenv TEST2VAR5 VALUE_TOKEN201803301333_5
  11: setenv TESTVAR6 VALUE_TOKEN201803301333_6
  12: setenv TEST2VAR6 VALUE_TOKEN201803301333_6
  13: setenv TESTVAR7 VALUE_TOKEN201803301333_7
  14: setenv TEST2VAR7 VALUE_TOKEN201803301333_7
  15: setenv TESTVAR8 VALUE_TOKEN201803301333_8
  16: setenv TEST2VAR8 VALUE_TOKEN201803301333_8
  17: setenv TESTVAR9 VALUE_TOKEN201803301333_9
  18: setenv TEST2VAR9 VALUE_TOKEN201803301333_9
  19: setenv TESTVAR10 VALUE_TOKEN201803301333_10
  20: setenv TEST2VAR10 VALUE_TOKEN201803301333_10
  21: ./display_env
  22: 
  23: setenv TESTVAR1=VALUE_TOKEN201803301333_1
  24: setenv TEST2VAR1=VALUE_TOKEN201803301333_1
  25: setenv TESTVAR2=VALUE_TOKEN201803301333_2
  26: setenv TEST2VAR2=VALUE_TOKEN201803301333_2
  27: setenv TESTVAR3=VALUE_TOKEN201803301333_3
  28: setenv TEST2VAR3=VALUE_TOKEN201803301333_3
  29: setenv TESTVAR4=VALUE_TOKEN201803301333_4
  30: setenv TEST2VAR4=VALUE_TOKEN201803301333_4
  31: setenv TESTVAR5=VALUE_TOKEN201803301333_5
  32: setenv TEST2VAR5=VALUE_TOKEN201803301333_5
  33: setenv TESTVAR6=VALUE_TOKEN201803301333_6
  34: setenv TEST2VAR6=VALUE_TOKEN201803301333_6
  35: setenv TESTVAR7=VALUE_TOKEN201803301333_7
  36: setenv TEST2VAR7=VALUE_TOKEN201803301333_7
  37: setenv TESTVAR8=VALUE_TOKEN201803301333_8
  38: setenv TEST2VAR8=VALUE_TOKEN201803301333_8
  39: setenv TESTVAR9=VALUE_TOKEN201803301333_9
  40: setenv TEST2VAR9=VALUE_TOKEN201803301333_9
  41: setenv TESTVAR10=VALUE_TOKEN201803301333_10
  42: setenv TEST2VAR10=VALUE_TOKEN201803301333_10
  43: ./display_env
  44: 
  45: export TESTVAR1=VALUE_TOKEN201803301333_1
  46: export TEST2VAR1=VALUE_TOKEN201803301333_1
  47: export TESTVAR2=VALUE_TOKEN201803301333_2
  48: export TEST2VAR2=VALUE_TOKEN201803301333_2
  49: export TESTVAR3=VALUE_TOKEN201803301333_3
  50: export TEST2VAR3=VALUE_TOKEN201803301333_3
  51: export TESTVAR4=VALUE_TOKEN201803301333_4
  52: export TEST2VAR4=VALUE_TOKEN201803301333_4
  53: export TESTVAR5=VALUE_TOKEN201803301333_5
  54: export TEST2VAR5=VALUE_TOKEN201803301333_5
  55: export TESTVAR6=VALUE_TOKEN201803301333_6
  56: export TEST2VAR6=VALUE_TOKEN201803301333_6
  57: export TESTVAR7=VALUE_TOKEN201803301333_7
  58: export TEST2VAR7=VALUE_TOKEN201803301333_7
  59: export TESTVAR8=VALUE_TOKEN201803301333_8
  60: export TEST2VAR8=VALUE_TOKEN201803301333_8
  61: export TESTVAR9=VALUE_TOKEN201803301333_9
  62: export TEST2VAR9=VALUE_TOKEN201803301333_9
  63: export TESTVAR10=VALUE_TOKEN201803301333_10
  64: export TEST2VAR10=VALUE_TOKEN201803301333_10
  65: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TESTVAR1=VALUE_TOKEN201803301333_1`
  FAILURE    expected_to match_regex `TESTVAR2=VALUE_TOKEN201803301333_2`
  FAILURE    expected_to match_regex `TESTVAR3=VALUE_TOKEN201803301333_3`
  FAILURE    expected_to match_regex `TESTVAR4=VALUE_TOKEN201803301333_4`
  FAILURE    expected_to match_regex `TESTVAR5=VALUE_TOKEN201803301333_5`
  FAILURE    expected_to match_regex `TESTVAR6=VALUE_TOKEN201803301333_6`
  FAILURE    expected_to match_regex `TESTVAR7=VALUE_TOKEN201803301333_7`
  FAILURE    expected_to match_regex `TESTVAR8=VALUE_TOKEN201803301333_8`
  FAILURE    expected_to match_regex `TESTVAR9=VALUE_TOKEN201803301333_9`
  FAILURE    expected_to match_regex `TESTVAR10=VALUE_TOKEN201803301333_10`
  FAILURE    expected_to match_regex `TEST2VAR1=VALUE_TOKEN201803301333_1`
  FAILURE    expected_to match_regex `TEST2VAR2=VALUE_TOKEN201803301333_2`
  FAILURE    expected_to match_regex `TEST2VAR3=VALUE_TOKEN201803301333_3`
  FAILURE    expected_to match_regex `TEST2VAR4=VALUE_TOKEN201803301333_4`
  FAILURE    expected_to match_regex `TEST2VAR5=VALUE_TOKEN201803301333_5`
  FAILURE    expected_to match_regex `TEST2VAR6=VALUE_TOKEN201803301333_6`
  FAILURE    expected_to match_regex `TEST2VAR7=VALUE_TOKEN201803301333_7`
  FAILURE    expected_to match_regex `TEST2VAR8=VALUE_TOKEN201803301333_8`
  FAILURE    expected_to match_regex `TEST2VAR9=VALUE_TOKEN201803301333_9`
  FAILURE    expected_to match_regex `TEST2VAR10=VALUE_TOKEN201803301333_10`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

minishell/builtins/setenv/001-no-argument (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `setenv` (or `export`) without any argument results in the same behavior as `env` (display environment variables).

  Before test:
   1: # storing all environment variables except OLDPWD and _
   2: env | awk 'BEGIN {FS="="} $0 !~ /^(OLDPWD|_)/ {print $1"="}' > "./stored_env"

  STDIN:
   1: setenv
   2: export

  STDOUT:
  FAILURE    expected_to match_each_regex_of_file `./stored_env`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

minishell/builtins/setenv/003-set-existing-variable (FAILED)

  Description:
  The purpose of this test is to check that the builtin `setenv` (or `export`) can add a new variable to the environment, either with the syntax `setenv KEY VALUE` or with `setenv KEY=VALUE`.

  Before test:
   1: export "TESTVAR1=OLD_TOKEN201803301333"

  STDIN:
   1: setenv TESTVAR1 NEW_TOKEN201803301333
   2: ./display_env
   3: 
   4: setenv TESTVAR1=NEW_TOKEN201803301333
   5: ./display_env
   6: 
   7: export TESTVAR1=NEW_TOKEN201803301333
   8: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `TESTVAR1=NEW_TOKEN201803301333`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

minishell/builtins/setenv/004-invalid-identifier (FAILED)

  Description:
  The purpose of this test is to check that using a wrong variable name with the builtin `setenv` (or `export`) results in error.

  STDIN:
   1: setenv 42
   2: export 42

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `(not.*identifier|must begin.*letter)`
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/errors/005-too-many-symbolic-links-encountered (FAILED)

  Description:
  The purpose of this test is to check that using a symbolic link resulting in ELOOP error as first argument with the builtin `cd` results in error and not changing current directory.

  Before test:
   1: rm -f "./symbolic_link1" "./symbolic_link2" "./symbolic_link3"
   2: ln -s "./symbolic_link1" "./symbolic_link2"
   3: ln -s "./symbolic_link2" "./symbolic_link3"
   4: ln -s "./symbolic_link3" "./symbolic_link1"

  STDIN:
   1: cd symbolic_link1
   2: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Tt]oo many.*symbolic links`
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/errors/001-not-a-directory (FAILED)

  Description:
  The purpose of this test is to check that using a file name as first argument with the builtin `cd` results in error and not changing current directory.

  Before test:
   1: touch "./not_a_directory"

  STDIN:
   1: cd not_a_directory
   2: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Nn]ot a directory`
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/errors/007-no-such-file-or-directory (FAILED)

  Description:
  The purpose of this test is to check that using a non-existing path as first argument with the builtin `cd` results in error and not changing current directory.

  Before test:
   1: rm -f "./no_such_file_or_directory"

  STDIN:
   1: cd no_such_file_or_directory
   2: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Nn]o such file or directory`
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/errors/003-permission-denied (FAILED)

  Description:
  The purpose of this test is to check that using a directory without any permission as first argument with the builtin `cd` results in error and not changing current directory.

  Before test:
   1: if [ -d "./permission_denied" ]; then chmod 777 "./permission_denied"; fi
   2: rm -rf "./permission_denied"
   3: mkdir -m 0 "./permission_denied"

  STDIN:
   1: cd permission_denied
   2: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Pp]ermission denied`
  (no output)

  After test:
   1: if [ -d "./permission_denied" ]; then chmod 777 "./permission_denied"; fi
   2: rm -rf "./permission_denied"

----------------------------------------------------------------

minishell/builtins/cd/errors/008-no-such-file-or-directory-2 (FAILED)

  Description:
  The purpose of this test is to check that using a non-existing path as first argument with the builtin `cd` results in a Shell termination with an error status code.

  Before test:
   1: rm -f "./no_such_file_or_directory"

  STDIN:
   1: cd no_such_file_or_directory

  STDOUT:
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/cd/errors/002-not-a-directory-2 (FAILED)

  Description:
  The purpose of this test is to check that using a file name as first argument with the builtin `cd` results in a Shell termination with a failure exit status.

  Before test:
   1: touch "./not_a_directory"

  STDIN:
   1: cd not_a_directory

  STDOUT:
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/cd/errors/004-permission-denied-2 (FAILED)

  Description:
  The purpose of this test is to check that using a directory without any permission as first argument with the builtin `cd` results in error and not changing current directory.

  Before test:
   1: if [ -d "./permission_denied" ]; then chmod 777 "./permission_denied"; fi
   2: rm -rf "./permission_denied"
   3: mkdir -m 0 "./permission_denied"

  STDIN:
   1: cd permission_denied

  STDOUT:
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

  After test:
   1: if [ -d "./permission_denied" ]; then chmod 777 "./permission_denied"; fi
   2: rm -rf "./permission_denied"

----------------------------------------------------------------

minishell/builtins/cd/errors/006-too-many-symbolic-links-encountered-2 (FAILED)

  Description:
  The purpose of this test is to check that using a symbolic link resulting in ELOOP error as first argument with the builtin `cd` results in a Shell termination with a failure exit status.

  Before test:
   1: rm -f "./symbolic_link1" "./symbolic_link2" "./symbolic_link3"
   2: ln -s "./symbolic_link1" "./symbolic_link2"
   3: ln -s "./symbolic_link2" "./symbolic_link3"
   4: ln -s "./symbolic_link3" "./symbolic_link1"

  STDIN:
   1: cd symbolic_link1

  STDOUT:
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/cd/errors/009-no-such-file-or-directory-symlink (FAILED)

  Description:
  The purpose of this test is to check that using a symbolic link that targets to a non-existing directory with the builtin `cd`  results in error and not changing current directory.

  Before test:
   1: rm -rf "./enoent_symlink" "./enoent_directory"
   2: ln -s "./enoent_directory" "./enoent_symlink"

  STDIN:
   1: cd ./enoent_symlink
   2: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Nn]o such file or directory`
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/errors/010-no-such-file-or-directory-symlink-2 (FAILED)

  Description:
  The purpose of this test is to check that using a symbolic link that targets to a non-existing directory with the builtin `cd`  results in error and not changing current directory.

  Before test:
   1: rm -rf "./enoent_symlink" "./enoent_directory"
   2: ln -s "./enoent_directory" "./enoent_symlink"

  STDIN:
   1: cd ./enoent_symlink

  STDOUT:
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/cd/004-parent-directory (FAILED)

  Description:
  The purpose of this test is to check that using `..` as first argument with the builtin `cd` results in moving to the parent directory.

  STDIN:
   1: cd ..
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester:PWD$`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/011-dotdot (FAILED)

  Description:
  The purpose of this test is to check that playing with relative paths with the builtin `cd` results in correctly changing the current directory.

  Before test:
   1: rm -rf "playing_with_dotdot"
   2: mkdir -p "playing_with_dotdot/1/2/3/4/5/6/7/8/9/10"

  STDIN:
   1: cd playing_with_dotdot
   2: cd ../playing_with_dotdot
   3: cd 1/2/3/4/../4/../4/../../3/4/5/6/7/8/9/10
   4: cd ../../../../../../../../../../1/2/3/4/5
   5: /home/pi/42ShellTester/tmp/display_pwd
   6: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp/playing_with_dotdot/1/2/3/4/5:PWD`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp/playing_with_dotdot/1/2/3/4/5$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/013-absolute-path (FAILED)

  Description:
  The purpose of this test is to check that using an absolute path as first argument with the builtin `cd` results in moving to the correct directory.

  Before test:
   1: rm -rf "./my_sub_directory"
   2: mkdir -p "./my_sub_directory/and_another_one/"

  STDIN:
   1: cd /home/pi/42ShellTester/tmp/my_sub_directory/and_another_one
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp/my_sub_directory/and_another_one:PWD`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp/my_sub_directory/and_another_one$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/002-current-directory (FAILED)

  Description:
  The purpose of this test is to check that using `.` as first argument with the builtin `cd` results in not changing current directory.

  STDIN:
   1: cd .
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/001-no-arg (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `cd` without any argument results in moving to the HOME directory.

  STDIN:
   1: cd
   2: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmp$`
  FAILURE    expected_to match_regex `PWD:/home/pi:PWD`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/008-symbolic-link-2 (FAILED)

  Description:
  The purpose of this test is to check that using a symbolic link as first argument with the builtin `cd` results in moving to the linked directory. In this test, the directory is linked with to chained symbolic links.

  Before test:
   1: rm -f "./symbolic_link1" "./symbolic_link2"
   2: mkdir -p "./sub_directory"
   3: ln -s "./sub_directory" "./symbolic_link1"
   4: ln -s "./symbolic_link1" "./symbolic_link2"

  STDIN:
   1: cd symbolic_link2
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp/sub_directory:PWD$`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp/symbolic_link2$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/003-current-directory-2 (FAILED)

  Description:
  The purpose of this test is to check that using a relative path to the current directory as argument with the builtin `cd` results in not changing the current directory. The environment variable must not be changed.

  STDIN:
   1: cd ../tmp
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/006-root-path-2 (FAILED)

  Description:
  The purpose of this test is to check that using the root path as first argument with the builtin `cd` results in moving to the correct directory.

  STDIN:
   1: cd /.
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/:PWD`
  FAILURE    expected_to match_regex `^PWD=/$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/options/001-not-following-links (FAILED)

  Description:
  The purpose of this test is to check that using symbolic links twice with the builtin `cd` and the option `-P` results in a correct environment variable PWD. The option `-P` makes the Shell to resolve symbolic links.

  Before test:
   1: rm -fr "./sub_directory_link" "./sub_directory"
   2: mkdir -p "./sub_directory/sub_sub_directory"
   3: ln -s "./sub_directory" "./sub_directory_link"
   4: ln -s "./sub_sub_directory" "./sub_directory/sub_sub_directory_link"

  STDIN:
   1: cd -P sub_directory_link
   2: cd -P sub_sub_directory_link
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD=/home/pi/42ShellTester/tmp/sub_directory/sub_sub_directory`
  (no output)

  STDERR:
  SUCCESS    might be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/options/002-oldpwd (FAILED)

  Description:
  The purpose of this test is to check that using `-` as first argument with the builtin `cd` results in moving the previous current directory.

  STDIN:
   1: cd /
   2: cd -
   3: /home/pi/42ShellTester/tmp/display_pwd

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/012-dot (FAILED)

  Description:
  The purpose of this test is to check that playing with relative paths to the current directory with the builtin `cd` results in not changing the current directory.

  STDIN:
   1: cd .
   2: cd ./
   3: cd ./.
   4: cd ././
   5: cd ./././././././././.
   6: /home/pi/42ShellTester/tmp/display_pwd
   7: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp:PWD`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/010-update-OLDPWD (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `cd` results in a modified environment variable `PWD`.

  Before test:
   1: rm -rf "TOKEN201803301333"
   2: mkdir -p "./TOKEN201803301333/TOKEN201803301333"

  STDIN:
   1: cd TOKEN201803301333
   2: cd TOKEN201803301333
   3: ../../display_env

  STDOUT:
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp/TOKEN201803301333/TOKEN201803301333$`
  FAILURE    expected_to match_regex `^OLDPWD=/home/pi/42ShellTester/tmp/TOKEN201803301333$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/005-root-path (FAILED)

  Description:
  The purpose of this test is to check that using the root path as first argument with the builtin `cd` results in moving to the correct directory.

  STDIN:
   1: cd /
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/:PWD`
  FAILURE    expected_to match_regex `^PWD=/$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/cd/007-symbolic-link (FAILED)

  Description:
  The purpose of this test is to check that using a symbolic link as first argument with the builtin `cd` results in moving the linked directory.

  Before test:
   1: rm -f "./symbolic_link"
   2: mkdir -p "./sub_directory"
   3: ln -s "./sub_directory" "./symbolic_link"

  STDIN:
   1: cd symbolic_link
   2: /home/pi/42ShellTester/tmp/display_pwd
   3: /home/pi/42ShellTester/tmp/display_env

  STDOUT:
  FAILURE    expected_to match_regex `PWD:/home/pi/42ShellTester/tmp/sub_directory:PWD$`
  FAILURE    expected_to match_regex `^PWD=/home/pi/42ShellTester/tmp/symbolic_link$`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

minishell/builtins/exit/errors/001-too-many-args (FAILED)

  Description:
  The purpose of this test is to check that using a wrong number of arguments with the builtin `exit` does not result in the Shell termination but an error on standard error.

  STDIN:
   1: exit 21 42
   2: ./write_on_stdout TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `([Tt]oo many arguments|[Aa]rgument list too long)`
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/exit/errors/002-non-numeric-argument (FAILED)

  Description:
  The purpose of this test is to check that using a non-numeric argument with the builtin `exit` results in the Shell termination and an error on standard error.

  STDIN:
   1: exit abc
   2: ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    expected_to_not match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  WARNING    might_not be_empty
  WARNING    might match_regex `[Nn]umeric argument required`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/builtins/exit/002-status-passed-as-argument (FAILED)

  Description:
  The purpose of this test is to check that using a number as first argument with the builtin `exit` results in the Shell termination with given number as exit status.

  STDIN:
   1: exit 42

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `42`

----------------------------------------------------------------

minishell/builtins/exit/003-status-of-last-command (FAILED)

  Description:
  The purpose of this test is to check that using the builtin `exit` without any argument results in a Shell termination and the exit status of the previous command.

  STDIN:
   1: ./exit_with_status 42
   2: exit

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `42`

----------------------------------------------------------------

minishell/misc/001-copy-of-environment (FAILED)

  Description:
  A Shell must send a copy of the environment to its child processes.

  Before test:
   1: export COPYENV_VAR1="TOKEN201803301333_VAR1"
   2: export COPYENV_VAR2="TOKEN201803301333_VAR2"
   3: export COPYENV_VAR3="TOKEN201803301333_VAR3"

  STDIN:
   1: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `COPYENV_VAR1=TOKEN201803301333_VAR1`
  FAILURE    expected_to match_regex `COPYENV_VAR2=TOKEN201803301333_VAR2`
  FAILURE    expected_to match_regex `COPYENV_VAR3=TOKEN201803301333_VAR3`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

minishell/binary/005-binary-test-wrong-path (FAILED)

  Description:
  This test purpose is to check if your shell is not able to use binary with a wrong PATH
  We are changing the actual PATH by PATH=NULL
  And executing the commande ls

  Before test:
   1: export PATH="/"

  STDIN:
   1: ls

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Cc]ommand not found`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

minishell/binary/007-binary-permission-denied (FAILED)

  Description:
  The purpose of this test is to check that trying to execute a non-permitted binary results in an error on standard error and a failure exit status.

  Before test:
   1: rm -rf ./permission_denied
   2: touch ./permission_denied
   3: chmod 0 ./permission_denied

  STDIN:
   1: ./permission_denied

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Pp]ermission denied`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status 0

  After test:
   1: if [ -d "./permission_denied" ]; then chmod 777 "./permission_denied"; fi
   2: rm -rf "./permission_denied"

----------------------------------------------------------------

minishell/binary/008-binary-too-many-symbolic-links-encountered (FAILED)

  Description:
  The purpose of this test is to check that trying to execute a path that encounters an infinite loop of symbolic link results in an error on standard error and a failure exit status.

  Before test:
   1: rm -rf ./symbolic_link1 ./symbolic_link2 ./symbolic_link3
   2: ln -s ./symbolic_link1 ./symbolic_link2
   3: ln -s ./symbolic_link2 ./symbolic_link3
   4: ln -s ./symbolic_link3 ./symbolic_link1

  STDIN:
   1: ./symbolic_link1

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Tt]oo many.*symbolic links`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status 0

----------------------------------------------------------------

minishell/binary/003-binary-test-exec-order (FAILED)

  Description:
  The purpose of this test is to check that the Shell correctly finds binaries by iterating on paths within the environment variable PATH from left to right.

  Before test:
   1: mkdir -p "./virtual_path_1" "./virtual_path_2"
   2: cp "./write_on_stdout" "./virtual_path_1/fake_echo"
   3: cp "./write_on_stderr" "./virtual_path_2/fake_echo"
   4: export PATH="/home/pi/42ShellTester/tmp/virtual_path_1:/home/pi/42ShellTester/tmp/virtual_path_2"

  STDIN:
   1: fake_echo TOKEN201803301333

  STDOUT:
  FAILURE    expected_to match_regex TOKEN201803301333
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

minishell/binary/004-binary-test-empty-path (FAILED)

  Description:
  The purpose of this test is to check that the Shell finds binaries that are located in the current directory when the environment variable PATH is empty.

  Before test:
   1: export PATH=""

  STDIN:
   1: write_on_stdout "TOKEN201803301333"

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

minishell/binary/006-binary-undefined-path (FAILED)

  Description:
  The purpose of this test is to check that the Shell retrieves the default value of the environment variable PATH if not set. This test depends on the presence of the UNIX binary `ls`, located in a path within the default environment variable PATH.

  Before test:
   1: rm -rf "TOKEN201803301333_006-BINARY-UNDEFINED-PATH"
   2: touch "TOKEN201803301333_006-BINARY-UNDEFINED-PATH"
   3: unset PATH

  STDIN:
   1: ls

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_006-BINARY-UNDEFINED-PATH`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

minishell/binary/002-binary-path-absolute (FAILED)

  Description:
  The purpose of this test is to check that the Shell correctly finds binaries through their absolute path.

  Before test:
   1: mkdir -p "./virtual_path"
   2: rm -f "./virtual_path/write_on_stdout"
   3: cp "./write_on_stdout" "./virtual_path/write_on_stdout"
   4: export PATH=""

  STDIN:
   1: /home/pi/42ShellTester/tmp/write_on_stdout TOKEN201803301333_1
   2: /home/pi/42ShellTester/tmp/virtual_path/write_on_stdout TOKEN201803301333_2

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_1`
  FAILURE    expected_to match_regex `TOKEN201803301333_2`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

minishell/binary/001-binary-path-relative (FAILED)

  Description:
  The purpose of this test is to check that the Shell correctly finds binaries within the PATH.

  Before test:
   1: mkdir -p "./virtual_path/p1" "./virtual_path/p2"
   2: rm -f "./virtual_path/p1/display_my_name1" "./virtual_path/p2/display_my_name2"
   3: cp "./display_program_name" "./virtual_path/p1/display_my_name1"
   4: cp "./display_program_name" "./virtual_path/p2/display_my_name2"
   5: export PATH="/home/pi/42ShellTester/tmp/virtual_path/p1:/home/pi/42ShellTester/tmp/virtual_path/p2"

  STDIN:
   1: display_my_name1
   2: display_my_name2

  STDOUT:
  FAILURE    expected_to match_regex `display_my_name1`
  FAILURE    expected_to match_regex `display_my_name2`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

bonuses/tilde-expansion/003-expanded-with-PWD-1 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be expanded with the environment variable PWD when followed by the symbol `+`.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~+

  STDOUT:
  SUCCESS    expected_to_not match_regex `~[+]`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333[+]`
  FAILURE    expected_to match_regex `^/home/pi/42ShellTester/tmp$`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/005-expanded-with-OLDPWD-1 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be expanded with the environment variable OLDPWD when followed by the symbol `+`.

  Before test:
   1: rm -rf "./TOKEN201803301333_SUBDIRECTORY"
   2: mkdir "./TOKEN201803301333_SUBDIRECTORY"
   3: export "HOME=/TOKEN201803301333"

  STDIN:
   1: cd ./TOKEN201803301333_SUBDIRECTORY
   2: /home/pi/42ShellTester/tmp/write_on_stdout ~-

  STDOUT:
  SUCCESS    expected_to_not match_regex `~-`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333-`
  FAILURE    expected_to match_regex `^/home/pi/42ShellTester/tmp$`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/004-expanded-with-PWD-2 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be expanded with the environment variable PWD when followed by the symbol `+`.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~+/TOKEN201803301333_SUBDIRECTORY

  STDOUT:
  SUCCESS    expected_to_not match_regex `~+/TOKEN201803301333_SUBDIRECTORY`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333[+]/TOKEN201803301333_SUBDIRECTORY`
  FAILURE    expected_to match_regex `^/home/pi/42ShellTester/tmp/TOKEN201803301333_SUBDIRECTORY$`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/006-expanded-with-OLDPWD-2 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be expanded with the environment variable OLDPWD when followed by the symbol `+`.

  Before test:
   1: rm -rf "./TOKEN201803301333_SUBDIRECTORY"
   2: mkdir "./TOKEN201803301333_SUBDIRECTORY"
   3: export "HOME=/TOKEN201803301333"

  STDIN:
   1: cd ./TOKEN201803301333_SUBDIRECTORY
   2: /home/pi/42ShellTester/tmp/write_on_stdout ~-/TOKEN201803301333_OTHERDIRECTORY

  STDOUT:
  SUCCESS    expected_to_not match_regex `~-/TOKEN201803301333_OTHERDIRECTORY`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333-/TOKEN201803301333_OTHERDIRECTORY`
  FAILURE    expected_to match_regex `^/home/pi/42ShellTester/tmp/TOKEN201803301333_OTHERDIRECTORY$`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/002-expanded-with-HOME-2 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` followed by the symbol slash `/` may be expanded with the environment variable HOME.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~/TOKEN201803301333_SUBDIRECTORY

  STDOUT:
  SUCCESS    expected_to_not match_regex `~`
  FAILURE    expected_to match_regex `^/TOKEN201803301333/TOKEN201803301333_SUBDIRECTORY$`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/not-expanded/002-not-expanded-with-HOME-2 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be not expanded when not followed by an authorized symbol or user name.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~TOKEN201803301333_UNKNOWNUSER

  STDOUT:
  FAILURE    expected_to match_regex `^~TOKEN201803301333_UNKNOWNUSER$`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333TOKEN201803301333_UNKNOWNUSER`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/not-expanded/001-not-expanded-with-HOME-1 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be not expanded when not followed by an authorized symbol or user name.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~~

  STDOUT:
  FAILURE    expected_to match_regex `^~~$`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/not-expanded/003-not-expanded-with-PWD (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` is not expanded with the environment variable PWD when not followed by the symbol `/`.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~+TOKEN201803301333_SUBDIRECTORY

  STDOUT:
  FAILURE    expected_to match_regex `^~[+]TOKEN201803301333_SUBDIRECTORY$`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333[+]TOKEN201803301333_SUBDIRECTORY`
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmpTOKEN201803301333_SUBDIRECTORY`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/not-expanded/004-not-expanded-with-OLDPWD (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` is not expanded with the environment variable OLDPWD when not followed by the symbol `/`.

  Before test:
   1: rm -rf "./TOKEN201803301333_SUBDIRECTORY"
   2: mkdir "./TOKEN201803301333_SUBDIRECTORY"
   3: export "HOME=/TOKEN201803301333"

  STDIN:
   1: cd ./TOKEN201803301333_SUBDIRECTORY
   2: /home/pi/42ShellTester/tmp/write_on_stdout ~-TOKEN201803301333_OTHERDIRECTORY

  STDOUT:
  FAILURE    expected_to match_regex `^~-TOKEN201803301333_OTHERDIRECTORY$`
  SUCCESS    expected_to_not match_regex `/TOKEN201803301333-/TOKEN201803301333_OTHERDIRECTORY`
  SUCCESS    expected_to_not match_regex `/home/pi/42ShellTester/tmp/TOKEN201803301333_OTHERDIRECTORY`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/tilde-expansion/001-expanded-with-HOME-1 (FAILED)

  Description:
  The purpose of this test is to check that the symbol tilde `~` may be expanded with the environment variable HOME.

  Before test:
   1: export "HOME=/TOKEN201803301333"

  STDIN:
   1: ./write_on_stdout ~

  STDOUT:
  SUCCESS    expected_to_not match_regex `~`
  FAILURE    expected_to match_regex `^/TOKEN201803301333$`
  (no output)

  STDERR:
  (no output)

----------------------------------------------------------------

bonuses/separators/mixed/004-or-and (FAILED)

  Description:
  The purpose of this test is to check that using the two separators OR `||` and AND `&&` applies the good logic: The second command is executed if the first one fails, and the third command is executed if the second one succeeds or is not executed.

  STDIN:
   1: ./exit_with_status 42 || ./write_on_stderr TOKEN201803301333_ERROR 21 && ./write_on_stdout TOKEN201803301333_SUCCESS

  STDOUT:
  SUCCESS    expected_to be_empty
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_ERROR`
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `21`

----------------------------------------------------------------

bonuses/separators/mixed/002-and-or (FAILED)

  Description:
  The purpose of this test is to check that using the two separators AND `&&` and OR `||` applies the good logic: The second command is executed if the first one succeeds, and the third command is executed if the second one fails or is not executed.

  STDIN:
   1: ./exit_with_status 0 && ./write_on_stderr TOKEN201803301333_ERROR 21 || ./write_on_stdout TOKEN201803301333_SUCCESS

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_SUCCESS`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_ERROR`
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/mixed/005-or-and (FAILED)

  Description:
  The purpose of this test is to check that using the two separators OR `||` and AND `&&` applies the good logic: The second command is executed if the first one fails, and the third command is executed if the second one succeeds or is not executed.

  STDIN:
   1: ./exit_with_status 42 || ./write_on_stdout TOKEN201803301333_SUCCESS && ./write_on_stderr TOKEN201803301333_ERROR 21

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_SUCCESS`
  (no output)

  STDERR:
  FAILURE    expected_to match_regex `TOKEN201803301333_ERROR`
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `21`

----------------------------------------------------------------

bonuses/separators/mixed/006-or-and (FAILED)

  Description:
  The purpose of this test is to check that using the two separators OR `||` and AND `&&` applies the good logic: The second command is executed if the first one fails, and the third command is executed if the second one succeeds or is not executed.

  STDIN:
   1: ./exit_with_status 0 || ./write_on_stderr TOKEN201803301333_ERROR 21 && ./write_on_stdout TOKEN201803301333_SUCCESS

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_SUCCESS`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/mixed/001-and-or (FAILED)

  Description:
  The purpose of this test is to check that using the two separators AND `&&` and OR `||` applies the good logic: The second command is executed if the first one succeeds, and the third command is executed if the second one fails or is not executed.

  STDIN:
   1: ./exit_with_status 42 && ./write_on_stderr TOKEN201803301333_ERROR 21 || ./write_on_stdout TOKEN201803301333_SUCCESS

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_SUCCESS`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/mixed/003-and-or (FAILED)

  Description:
  The purpose of this test is to check that using the two separators AND `&&` and OR `||` applies the good logic: The second command is executed if the first one succeeds, and the third command is executed if the second one fails or is not executed.

  STDIN:
   1: ./exit_with_status 0 && ./write_on_stdout TOKEN201803301333_SUCCESS || ./write_on_stderr TOKEN201803301333_ERROR 21

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_SUCCESS`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/and/errors/002-parse-error-too-much-symbol (FAILED)

  Description:
  Parsing test.
  The purpose of this test is to check that more than two '&' operators are detected as a syntax error.
  It should not execute the two commands `write_on_stdout` but display an error and exit with an error status code.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333 &&& ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    might_not match_regex `TOKEN201803301333`
  SUCCESS    might be_empty
  (no output)

  STDERR:
  WARNING    might_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

  MISC:
  FAILURE    expected_to_not exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/and/errors/001-parse-error-at-beginning (WARNING)

  Description:
  Parsing test.
  The purpose of this test is to check that the AND operator `&&` must be placed after a valid command.
  If not, the Shell should display an error and exit with an error status code.

  STDIN:
   1: && ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    might_not match_regex `TOKEN201803301333`
  SUCCESS    might be_empty
  (no output)

  STDERR:
  WARNING    might_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

  MISC:
  WARNING    might_not exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/and/001-run-twice (WARNING)

  Description:
  The purpose of this test is to check that the AND operator `&&` works with two valid commands.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333_LEFT && ./write_on_stdout TOKEN201803301333_RIGHT

  STDOUT:
  WARNING    might match_regex `TOKEN201803301333_LEFT`
  WARNING    might match_regex `TOKEN201803301333_RIGHT`
  (no output)

  STDERR:
  SUCCESS    might be_empty
  (no output)

----------------------------------------------------------------

bonuses/separators/and/002-do-not-run-second (WARNING)

  Description:
  The purpose of this test is to check that the AND operator `&&` makes the right command to not be executed if the left one exits with an error status code.
  The Shell should exit with the status code of the executed command.

  STDIN:
   1: ./exit_with_status 42 && ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    might_not match_regex TOKEN201803301333
  SUCCESS    might be_empty
  (no output)

  STDERR:
  SUCCESS    might be_empty
  (no output)

  MISC:
  WARNING    might exit_with_status `42`

----------------------------------------------------------------

bonuses/separators/and/003-run-until-failing (FAILED)

  Description:
  The purpose of this test is to check that using the AND separator `&&` with chained commands results in the execution of all until the first fail.

  STDIN:
   1: ./exit_with_status 0 && ./exit_with_status 0 && ./exit_with_status 0 && ./exit_with_status 0 && ./write_on_stdout TOKEN201803301333_FIRST && ./exit_with_status 42 && ./write_on_stdout TOKEN201803301333_SECOND

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_SECOND`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  FAILURE    expected_to exit_with_status `42`

----------------------------------------------------------------

bonuses/separators/or/errors/002-parse-error-too-much-symbol (WARNING)

  Description:
  Parsing test.
  The purpose of this test is to check that using more than two pipe symbols `|` is detected as an error.
  The Shell should display an error and exit with a error status code.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333 ||| ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  WARNING    might_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

  MISC:
  WARNING    might_not exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/or/errors/001-parse-error-at-beginning (WARNING)

  Description:
  Parsing test.
  The purpose of this test is to check that the OR operator `||` must be placed after a valid command.
  If not, the Shell should display an error and exit with an error status code.

  STDIN:
   1: || ./write_on_stdout TOKEN201803301333

  STDOUT:
  SUCCESS    might be_empty
  (no output)

  STDERR:
  WARNING    might_not be_empty
  WARNING    might match_regex `([Ss]yntax|[Pp]arse) error`
  (no output)

  MISC:
  WARNING    might_not exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/or/002-run-second-only (WARNING)

  Description:
  The purpose of this test is to check that the OR operator `||` makes the right command to be executed if the left one exits with an error status code.

  STDIN:
   1: ./exit_with_status 42 || ./write_on_stdout TOKEN201803301333

  STDOUT:
  WARNING    might match_regex `TOKEN201803301333`
  (no output)

  STDERR:
  SUCCESS    might be_empty
  (no output)

  MISC:
  SUCCESS    might exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/or/003-run-until-succeeding (FAILED)

  Description:
  The purpose of this test is to check that using the OR separator `||` with chained commands results in the execution of all until the first succeed. The remaining commands are not executed.

  STDIN:
   1: ./exit_with_status 1 || ./exit_with_status 2 || ./exit_with_status 3 || ./exit_with_status 4 || ./write_on_stdout TOKEN201803301333_FIRST || ./write_on_stdout TOKEN201803301333_SECOND

  STDOUT:
  FAILURE    expected_to match_regex `TOKEN201803301333_FIRST`
  SUCCESS    expected_to_not match_regex `TOKEN201803301333_SECOND`
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

  MISC:
  SUCCESS    expected_to exit_with_status `0`

----------------------------------------------------------------

bonuses/separators/or/001-run-first-only (WARNING)

  Description:
  The purpose of this test is to check that the OR operator `||` makes the right command to not be executed if the left one exits with a success status.

  STDIN:
   1: ./write_on_stdout TOKEN201803301333_LEFT || ./write_on_stdout TOKEN201803301333_RIGHT

  STDOUT:
  WARNING    might match_regex TOKEN201803301333_LEFT
  SUCCESS    might_not match_regex TOKEN201803301333_RIGHT
  (no output)

  STDERR:
  SUCCESS    might be_empty
  (no output)

----------------------------------------------------------------

bonuses/inline-environment-variable/001-modifies-child-environment-1 (FAILED)

  Description:
  The purpose of this test is to check that a binary may have its environment to be modified by appending variables inline.

  Before test:
   1: unset "TOKEN201803301333_VARIABLE"

  STDIN:
   1: TOKEN201803301333_VARIABLE=TOKEN201803301333_VALUE ./display_env
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VARIABLE=TOKEN201803301333_VALUE$` once
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

bonuses/inline-environment-variable/002-modifies-child-environment-2 (FAILED)

  Description:
  The purpose of this test is to check that a binary may have its environment to be modified by appending variables inline.

  Before test:
   1: unset "TOKEN201803301333_VARIABLE"

  STDIN:
   1: TOKEN201803301333_VARIABLE1=TOKEN201803301333_VALUE1 TOKEN201803301333_VARIABLE2=TOKEN201803301333_VALUE2 TOKEN201803301333_VARIABLE3=TOKEN201803301333_VALUE3 ./display_env
   2: ./display_env

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333_VARIABLE1=TOKEN201803301333_VALUE1$` once
  FAILURE    expected_to match_regex `^TOKEN201803301333_VARIABLE2=TOKEN201803301333_VALUE2$` once
  FAILURE    expected_to match_regex `^TOKEN201803301333_VARIABLE3=TOKEN201803301333_VALUE3$` once
  (no output)

  STDERR:
  SUCCESS    expected_to be_empty
  (no output)

----------------------------------------------------------------

bonuses/inline-environment-variable/003-modifies-PATH-only (FAILED)

  Description:
  The purpose of this test is to check that a binary may have its environment to be modified by appending variables inline.

  Before test:
   1: rm -rf "temporary_directory"
   2: mkdir -p "temporary_directory"
   3: cd "temporary_directory"

  STDIN:
   1: PATH=.. write_on_stdout TOKEN201803301333
   2: exit_with_status 42

  STDOUT:
  FAILURE    expected_to match_regex `^TOKEN201803301333$`
  (no output)

  STDERR:
  FAILURE    expected_to_not be_empty
  WARNING    might match_regex `[Cc]ommand not found`
  (no output)

  MISC:
  SUCCESS    expected_to_not exit_with_status `42`
  FAILURE    expected_to_not exit_with_status `0`

Total tests: 281
Total failed tests: 262
Total pending tests: 3
